In archive libLSM303.a:

LSM303.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         00001164  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      00001398  00000000  00000000  00001198  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .text._ZN7TwoWire5writeEi 00000010  00000000  00000000  00002530  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  6 .text._ZN6LSM303C2Ev 00000072  00000000  00000000  00002540  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  7 .text._ZN6LSM30315timeoutOccurredEv 00000006  00000000  00000000  000025b2  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  8 .text._ZN6LSM30310setTimeoutEj 00000008  00000000  00000000  000025b8  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  9 .text._ZN6LSM30310getTimeoutEv 00000008  00000000  00000000  000025c0  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 10 .text._ZN6LSM30311writeAccRegEhh 00000056  00000000  00000000  000025c8  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 11 .text._ZN6LSM30310readAccRegEh 00000054  00000000  00000000  0000261e  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 12 .text._ZN6LSM30311writeMagRegEhh 0000005a  00000000  00000000  00002672  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 13 .text._ZN6LSM30313enableDefaultEv 0000001e  00000000  00000000  000026cc  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 14 .text._ZN6LSM30310readMagRegEi 000000c8  00000000  00000000  000026ea  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 15 .text._ZN6LSM30310setMagGainENS_7magGainE 00000036  00000000  00000000  000027b2  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 16 .text._ZN6LSM3037readAccEv 00000142  00000000  00000000  000027e8  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 17 .text._ZN6LSM3037readMagEv 0000015a  00000000  00000000  0000292a  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 18 .text._ZN6LSM3034readEv 00000016  00000000  00000000  00002a84  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 19 .text._ZN6LSM30312vector_crossEPKNS_6vectorES2_PS0_ 00000164  00000000  00000000  00002a9a  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 20 .text._ZN6LSM30310vector_dotEPKNS_6vectorES2_ 00000088  00000000  00000000  00002bfe  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 21 .text._ZN6LSM30316vector_normalizeEPNS_6vectorE 00000072  00000000  00000000  00002c86  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 22 .text._ZN6LSM3037headingENS_6vectorE 00000252  00000000  00000000  00002cf8  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 23 .text._ZN6LSM3037headingEv 0000008c  00000000  00000000  00002f4a  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 24 .text._ZN6LSM30311detectSA0_AEv 00000058  00000000  00000000  00002fd6  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 25 .text._ZN6LSM3034initEhh 0000005c  00000000  00000000  0000302e  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE

Disassembly of section .text._ZN7TwoWire5writeEi:

00000000 <_ZN7TwoWire5writeEi>:
{
	return io_timeout;
}

void LSM303::init(byte device, byte sa0_a)
{  
   0:	dc 01       	movw	r26, r24
   2:	ed 91       	ld	r30, X+
   4:	fc 91       	ld	r31, X
	_device = device;
   6:	01 90       	ld	r0, Z+
	switch (_device)
   8:	f0 81       	ld	r31, Z
   a:	e0 2d       	mov	r30, r0
   c:	09 95       	icall
   e:	08 95       	ret

Disassembly of section .text._ZN6LSM303C2Ev:

00000000 <_ZN6LSM303C1Ev>:
{
	return io_timeout;
}

void LSM303::init(byte device, byte sa0_a)
{  
   0:	fc 01       	movw	r30, r24
   2:	80 e0       	ldi	r24, 0x00	; 0
   4:	90 e0       	ldi	r25, 0x00	; 0
	_device = device;
   6:	a7 e0       	ldi	r26, 0x07	; 7
	switch (_device)
   8:	b4 e4       	ldi	r27, 0x44	; 68
   a:	80 8f       	std	Z+24, r24	; 0x18
   c:	91 8f       	std	Z+25, r25	; 0x19
   e:	a2 8f       	std	Z+26, r26	; 0x1a
  10:	b3 8f       	std	Z+27, r27	; 0x1b
	{
	case LSM303DLH_DEVICE:
	case LSM303DLM_DEVICE:
		if (sa0_a == LSM303_SA0_A_LOW)
  12:	80 e0       	ldi	r24, 0x00	; 0
  14:	90 e0       	ldi	r25, 0x00	; 0
			acc_address = ACC_ADDRESS_SA0_A_LOW;
		else if (sa0_a == LSM303_SA0_A_HIGH)
  16:	aa ef       	ldi	r26, 0xFA	; 250
  18:	b3 e4       	ldi	r27, 0x43	; 67
			acc_address = ACC_ADDRESS_SA0_A_HIGH;
		else
			acc_address = (detectSA0_A() == LSM303_SA0_A_HIGH) ? ACC_ADDRESS_SA0_A_HIGH : ACC_ADDRESS_SA0_A_LOW;
  1a:	84 8f       	std	Z+28, r24	; 0x1c
  1c:	95 8f       	std	Z+29, r25	; 0x1d
  1e:	a6 8f       	std	Z+30, r26	; 0x1e
  20:	b7 8f       	std	Z+31, r27	; 0x1f
  22:	80 e0       	ldi	r24, 0x00	; 0
  24:	90 e0       	ldi	r25, 0x00	; 0
		break;

	case LSM303DLHC_DEVICE:
		acc_address = ACC_ADDRESS_SA0_A_HIGH;
  26:	a4 e3       	ldi	r26, 0x34	; 52
  28:	b3 e4       	ldi	r27, 0x43	; 67
		break;
  2a:	80 a3       	std	Z+32, r24	; 0x20

	default:
		// try to auto-detect device
		if (detectSA0_A() == LSM303_SA0_A_HIGH)
  2c:	91 a3       	std	Z+33, r25	; 0x21
  2e:	a2 a3       	std	Z+34, r26	; 0x22
  30:	b3 a3       	std	Z+35, r27	; 0x23
  32:	20 e0       	ldi	r18, 0x00	; 0
		{
			// if device responds on 0011001b (SA0_A is high), assume DLHC
			acc_address = ACC_ADDRESS_SA0_A_HIGH;
  34:	30 e0       	ldi	r19, 0x00	; 0
  36:	42 e0       	ldi	r20, 0x02	; 2
			_device = LSM303DLHC_DEVICE;
  38:	54 ec       	ldi	r21, 0xC4	; 196
  3a:	24 a3       	std	Z+36, r18	; 0x24
  3c:	35 a3       	std	Z+37, r19	; 0x25
		}
		else
		{
			// otherwise, assume DLH or DLM (pulled low by default on Pololu boards); query magnetometer WHO_AM_I to differentiate these two
			acc_address = ACC_ADDRESS_SA0_A_LOW;
  3e:	46 a3       	std	Z+38, r20	; 0x26
  40:	57 a3       	std	Z+39, r21	; 0x27
			_device = (readMagReg(LSM303_WHO_AM_I_M) == 0x3C) ? LSM303DLM_DEVICE : LSM303DLH_DEVICE;
  42:	20 e0       	ldi	r18, 0x00	; 0
  44:	30 e8       	ldi	r19, 0x80	; 128
  46:	4e e0       	ldi	r20, 0x0E	; 14
  48:	54 ec       	ldi	r21, 0xC4	; 196
  4a:	20 a7       	std	Z+40, r18	; 0x28
  4c:	31 a7       	std	Z+41, r19	; 0x29
  4e:	42 a7       	std	Z+42, r20	; 0x2a
  50:	53 a7       	std	Z+43, r21	; 0x2b
  52:	20 e0       	ldi	r18, 0x00	; 0
  54:	30 e8       	ldi	r19, 0x80	; 128
		}
		break;
	}
}
  56:	40 e4       	ldi	r20, 0x40	; 64
  58:	54 ec       	ldi	r21, 0xC4	; 196
  5a:	24 a7       	std	Z+44, r18	; 0x2c
  5c:	35 a7       	std	Z+45, r19	; 0x2d
  5e:	46 a7       	std	Z+46, r20	; 0x2e
  60:	57 a7       	std	Z+47, r21	; 0x2f
  62:	83 e0       	ldi	r24, 0x03	; 3
  64:	81 ab       	std	Z+49, r24	; 0x31
  66:	88 e1       	ldi	r24, 0x18	; 24
  68:	82 ab       	std	Z+50, r24	; 0x32
  6a:	14 aa       	std	Z+52, r1	; 0x34
  6c:	13 aa       	std	Z+51, r1	; 0x33
  6e:	15 aa       	std	Z+53, r1	; 0x35
  70:	08 95       	ret

Disassembly of section .text._ZN6LSM30315timeoutOccurredEv:

00000000 <_ZN6LSM30315timeoutOccurredEv>:
{
	return io_timeout;
}

void LSM303::init(byte device, byte sa0_a)
{  
   0:	fc 01       	movw	r30, r24
   2:	85 a9       	ldd	r24, Z+53	; 0x35
   4:	08 95       	ret

Disassembly of section .text._ZN6LSM30310setTimeoutEj:

00000000 <_ZN6LSM30310setTimeoutEj>:
   0:	fc 01       	movw	r30, r24
   2:	74 ab       	std	Z+52, r23	; 0x34
   4:	63 ab       	std	Z+51, r22	; 0x33
	_device = device;
   6:	08 95       	ret

Disassembly of section .text._ZN6LSM30310getTimeoutEv:

00000000 <_ZN6LSM30310getTimeoutEv>:
{
	return io_timeout;
}

void LSM303::init(byte device, byte sa0_a)
{  
   0:	fc 01       	movw	r30, r24
   2:	83 a9       	ldd	r24, Z+51	; 0x33
   4:	94 a9       	ldd	r25, Z+52	; 0x34
	_device = device;
   6:	08 95       	ret

Disassembly of section .text._ZN6LSM30311writeAccRegEhh:

00000000 <_ZN6LSM30311writeAccRegEhh>:
{
	return io_timeout;
}

void LSM303::init(byte device, byte sa0_a)
{  
   0:	cf 92       	push	r12
   2:	df 92       	push	r13
   4:	ff 92       	push	r15
	_device = device;
   6:	0f 93       	push	r16
	switch (_device)
   8:	1f 93       	push	r17
   a:	df 93       	push	r29
   c:	cf 93       	push	r28
   e:	0f 92       	push	r0
  10:	cd b7       	in	r28, 0x3d	; 61
	{
	case LSM303DLH_DEVICE:
	case LSM303DLM_DEVICE:
		if (sa0_a == LSM303_SA0_A_LOW)
  12:	de b7       	in	r29, 0x3e	; 62
  14:	6c 01       	movw	r12, r24
			acc_address = ACC_ADDRESS_SA0_A_LOW;
		else if (sa0_a == LSM303_SA0_A_HIGH)
  16:	f6 2e       	mov	r15, r22
  18:	00 e0       	ldi	r16, 0x00	; 0
			acc_address = ACC_ADDRESS_SA0_A_HIGH;
		else
			acc_address = (detectSA0_A() == LSM303_SA0_A_HIGH) ? ACC_ADDRESS_SA0_A_HIGH : ACC_ADDRESS_SA0_A_LOW;
  1a:	10 e0       	ldi	r17, 0x00	; 0
  1c:	c8 01       	movw	r24, r16
  1e:	f6 01       	movw	r30, r12
  20:	62 a9       	ldd	r22, Z+50	; 0x32
  22:	49 83       	std	Y+1, r20	; 0x01
  24:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM30311writeAccRegEhh>
		break;

	case LSM303DLHC_DEVICE:
		acc_address = ACC_ADDRESS_SA0_A_HIGH;
  28:	c8 01       	movw	r24, r16
		break;
  2a:	6f 2d       	mov	r22, r15

	default:
		// try to auto-detect device
		if (detectSA0_A() == LSM303_SA0_A_HIGH)
  2c:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM30311writeAccRegEhh>
  30:	c8 01       	movw	r24, r16
  32:	49 81       	ldd	r20, Y+1	; 0x01
		{
			// if device responds on 0011001b (SA0_A is high), assume DLHC
			acc_address = ACC_ADDRESS_SA0_A_HIGH;
  34:	64 2f       	mov	r22, r20
  36:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM30311writeAccRegEhh>
			_device = LSM303DLHC_DEVICE;
  3a:	c8 01       	movw	r24, r16
  3c:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM30311writeAccRegEhh>
		}
		else
		{
			// otherwise, assume DLH or DLM (pulled low by default on Pololu boards); query magnetometer WHO_AM_I to differentiate these two
			acc_address = ACC_ADDRESS_SA0_A_LOW;
  40:	f6 01       	movw	r30, r12
			_device = (readMagReg(LSM303_WHO_AM_I_M) == 0x3C) ? LSM303DLM_DEVICE : LSM303DLH_DEVICE;
  42:	80 ab       	std	Z+48, r24	; 0x30
  44:	0f 90       	pop	r0
  46:	cf 91       	pop	r28
  48:	df 91       	pop	r29
  4a:	1f 91       	pop	r17
  4c:	0f 91       	pop	r16
  4e:	ff 90       	pop	r15
  50:	df 90       	pop	r13
  52:	cf 90       	pop	r12
  54:	08 95       	ret

Disassembly of section .text._ZN6LSM30310readAccRegEh:

00000000 <_ZN6LSM30310readAccRegEh>:
{
	return io_timeout;
}

void LSM303::init(byte device, byte sa0_a)
{  
   0:	ff 92       	push	r15
   2:	0f 93       	push	r16
   4:	1f 93       	push	r17
	_device = device;
   6:	cf 93       	push	r28
	switch (_device)
   8:	df 93       	push	r29
   a:	8c 01       	movw	r16, r24
   c:	f6 2e       	mov	r15, r22
   e:	c0 e0       	ldi	r28, 0x00	; 0
  10:	d0 e0       	ldi	r29, 0x00	; 0
	{
	case LSM303DLH_DEVICE:
	case LSM303DLM_DEVICE:
		if (sa0_a == LSM303_SA0_A_LOW)
  12:	ce 01       	movw	r24, r28
  14:	f8 01       	movw	r30, r16
			acc_address = ACC_ADDRESS_SA0_A_LOW;
		else if (sa0_a == LSM303_SA0_A_HIGH)
  16:	62 a9       	ldd	r22, Z+50	; 0x32
  18:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM30310readAccRegEh>
			acc_address = ACC_ADDRESS_SA0_A_HIGH;
		else
			acc_address = (detectSA0_A() == LSM303_SA0_A_HIGH) ? ACC_ADDRESS_SA0_A_HIGH : ACC_ADDRESS_SA0_A_LOW;
  1c:	ce 01       	movw	r24, r28
  1e:	6f 2d       	mov	r22, r15
  20:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM30310readAccRegEh>
  24:	ce 01       	movw	r24, r28
		break;

	case LSM303DLHC_DEVICE:
		acc_address = ACC_ADDRESS_SA0_A_HIGH;
  26:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM30310readAccRegEh>
		break;
  2a:	f8 01       	movw	r30, r16

	default:
		// try to auto-detect device
		if (detectSA0_A() == LSM303_SA0_A_HIGH)
  2c:	80 ab       	std	Z+48, r24	; 0x30
  2e:	ce 01       	movw	r24, r28
  30:	62 a9       	ldd	r22, Z+50	; 0x32
  32:	41 e0       	ldi	r20, 0x01	; 1
		{
			// if device responds on 0011001b (SA0_A is high), assume DLHC
			acc_address = ACC_ADDRESS_SA0_A_HIGH;
  34:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM30310readAccRegEh>
			_device = LSM303DLHC_DEVICE;
  38:	ce 01       	movw	r24, r28
  3a:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM30310readAccRegEh>
		}
		else
		{
			// otherwise, assume DLH or DLM (pulled low by default on Pololu boards); query magnetometer WHO_AM_I to differentiate these two
			acc_address = ACC_ADDRESS_SA0_A_LOW;
  3e:	08 2f       	mov	r16, r24
  40:	ce 01       	movw	r24, r28
			_device = (readMagReg(LSM303_WHO_AM_I_M) == 0x3C) ? LSM303DLM_DEVICE : LSM303DLH_DEVICE;
  42:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM30310readAccRegEh>
  46:	80 2f       	mov	r24, r16
  48:	df 91       	pop	r29
  4a:	cf 91       	pop	r28
  4c:	1f 91       	pop	r17
  4e:	0f 91       	pop	r16
  50:	ff 90       	pop	r15
  52:	08 95       	ret

Disassembly of section .text._ZN6LSM30311writeMagRegEhh:

00000000 <_ZN6LSM30311writeMagRegEhh>:
{
	return io_timeout;
}

void LSM303::init(byte device, byte sa0_a)
{  
   0:	cf 92       	push	r12
   2:	df 92       	push	r13
   4:	ff 92       	push	r15
	_device = device;
   6:	0f 93       	push	r16
	switch (_device)
   8:	1f 93       	push	r17
   a:	df 93       	push	r29
   c:	cf 93       	push	r28
   e:	0f 92       	push	r0
  10:	cd b7       	in	r28, 0x3d	; 61
	{
	case LSM303DLH_DEVICE:
	case LSM303DLM_DEVICE:
		if (sa0_a == LSM303_SA0_A_LOW)
  12:	de b7       	in	r29, 0x3e	; 62
  14:	8c 01       	movw	r16, r24
			acc_address = ACC_ADDRESS_SA0_A_LOW;
		else if (sa0_a == LSM303_SA0_A_HIGH)
  16:	f6 2e       	mov	r15, r22
  18:	80 e0       	ldi	r24, 0x00	; 0
			acc_address = ACC_ADDRESS_SA0_A_HIGH;
		else
			acc_address = (detectSA0_A() == LSM303_SA0_A_HIGH) ? ACC_ADDRESS_SA0_A_HIGH : ACC_ADDRESS_SA0_A_LOW;
  1a:	c8 2e       	mov	r12, r24
  1c:	80 e0       	ldi	r24, 0x00	; 0
  1e:	d8 2e       	mov	r13, r24
  20:	c6 01       	movw	r24, r12
  22:	6e e1       	ldi	r22, 0x1E	; 30
  24:	70 e0       	ldi	r23, 0x00	; 0
		break;

	case LSM303DLHC_DEVICE:
		acc_address = ACC_ADDRESS_SA0_A_HIGH;
  26:	49 83       	std	Y+1, r20	; 0x01
  28:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM30311writeMagRegEhh>
		break;

	default:
		// try to auto-detect device
		if (detectSA0_A() == LSM303_SA0_A_HIGH)
  2c:	c6 01       	movw	r24, r12
  2e:	6f 2d       	mov	r22, r15
  30:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM30311writeMagRegEhh>
		{
			// if device responds on 0011001b (SA0_A is high), assume DLHC
			acc_address = ACC_ADDRESS_SA0_A_HIGH;
  34:	c6 01       	movw	r24, r12
  36:	49 81       	ldd	r20, Y+1	; 0x01
			_device = LSM303DLHC_DEVICE;
  38:	64 2f       	mov	r22, r20
  3a:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM30311writeMagRegEhh>
		}
		else
		{
			// otherwise, assume DLH or DLM (pulled low by default on Pololu boards); query magnetometer WHO_AM_I to differentiate these two
			acc_address = ACC_ADDRESS_SA0_A_LOW;
  3e:	c6 01       	movw	r24, r12
  40:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM30311writeMagRegEhh>
			_device = (readMagReg(LSM303_WHO_AM_I_M) == 0x3C) ? LSM303DLM_DEVICE : LSM303DLH_DEVICE;
  44:	f8 01       	movw	r30, r16
  46:	80 ab       	std	Z+48, r24	; 0x30
  48:	0f 90       	pop	r0
  4a:	cf 91       	pop	r28
  4c:	df 91       	pop	r29
  4e:	1f 91       	pop	r17
  50:	0f 91       	pop	r16
  52:	ff 90       	pop	r15
  54:	df 90       	pop	r13
		}
		break;
	}
}
  56:	cf 90       	pop	r12
  58:	08 95       	ret

Disassembly of section .text._ZN6LSM30313enableDefaultEv:

00000000 <_ZN6LSM30313enableDefaultEv>:
{
	return io_timeout;
}

void LSM303::init(byte device, byte sa0_a)
{  
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	ec 01       	movw	r28, r24
	_device = device;
   6:	60 e2       	ldi	r22, 0x20	; 32
	switch (_device)
   8:	47 e2       	ldi	r20, 0x27	; 39
   a:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM30313enableDefaultEv>
   e:	ce 01       	movw	r24, r28
  10:	62 e0       	ldi	r22, 0x02	; 2
	{
	case LSM303DLH_DEVICE:
	case LSM303DLM_DEVICE:
		if (sa0_a == LSM303_SA0_A_LOW)
  12:	40 e0       	ldi	r20, 0x00	; 0
  14:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM30313enableDefaultEv>
			acc_address = ACC_ADDRESS_SA0_A_LOW;
		else if (sa0_a == LSM303_SA0_A_HIGH)
  18:	df 91       	pop	r29
			acc_address = ACC_ADDRESS_SA0_A_HIGH;
		else
			acc_address = (detectSA0_A() == LSM303_SA0_A_HIGH) ? ACC_ADDRESS_SA0_A_HIGH : ACC_ADDRESS_SA0_A_LOW;
  1a:	cf 91       	pop	r28
  1c:	08 95       	ret

Disassembly of section .text._ZN6LSM30310readMagRegEi:

00000000 <_ZN6LSM30310readMagRegEi>:
{
	return io_timeout;
}

void LSM303::init(byte device, byte sa0_a)
{  
   0:	0f 93       	push	r16
   2:	1f 93       	push	r17
   4:	cf 93       	push	r28
	_device = device;
   6:	df 93       	push	r29
	switch (_device)
   8:	8c 01       	movw	r16, r24
   a:	eb 01       	movw	r28, r22
   c:	77 ff       	sbrs	r23, 7
   e:	00 c0       	rjmp	.+0      	; 0x10 <_ZN6LSM30310readMagRegEi+0x10>
  10:	8f ef       	ldi	r24, 0xFF	; 255
	{
	case LSM303DLH_DEVICE:
	case LSM303DLM_DEVICE:
		if (sa0_a == LSM303_SA0_A_LOW)
  12:	6d 3f       	cpi	r22, 0xFD	; 253
  14:	78 07       	cpc	r23, r24
			acc_address = ACC_ADDRESS_SA0_A_LOW;
		else if (sa0_a == LSM303_SA0_A_HIGH)
  16:	01 f0       	breq	.+0      	; 0x18 <_ZN6LSM30310readMagRegEi+0x18>
  18:	ef ef       	ldi	r30, 0xFF	; 255
			acc_address = ACC_ADDRESS_SA0_A_HIGH;
		else
			acc_address = (detectSA0_A() == LSM303_SA0_A_HIGH) ? ACC_ADDRESS_SA0_A_HIGH : ACC_ADDRESS_SA0_A_LOW;
  1a:	6e 3f       	cpi	r22, 0xFE	; 254
  1c:	7e 07       	cpc	r23, r30
  1e:	04 f4       	brge	.+0      	; 0x20 <_ZN6LSM30310readMagRegEi+0x20>
  20:	ff ef       	ldi	r31, 0xFF	; 255
  22:	6c 3f       	cpi	r22, 0xFC	; 252
  24:	7f 07       	cpc	r23, r31
		break;

	case LSM303DLHC_DEVICE:
		acc_address = ACC_ADDRESS_SA0_A_HIGH;
  26:	01 f4       	brne	.+0      	; 0x28 <_ZN6LSM30310readMagRegEi+0x28>
  28:	00 c0       	rjmp	.+0      	; 0x2a <_ZN6LSM30310readMagRegEi+0x2a>
		break;
  2a:	8f ef       	ldi	r24, 0xFF	; 255

	default:
		// try to auto-detect device
		if (detectSA0_A() == LSM303_SA0_A_HIGH)
  2c:	6e 3f       	cpi	r22, 0xFE	; 254
  2e:	78 07       	cpc	r23, r24
  30:	01 f0       	breq	.+0      	; 0x32 <_ZN6LSM30310readMagRegEi+0x32>
  32:	ef ef       	ldi	r30, 0xFF	; 255
		{
			// if device responds on 0011001b (SA0_A is high), assume DLHC
			acc_address = ACC_ADDRESS_SA0_A_HIGH;
  34:	6f 3f       	cpi	r22, 0xFF	; 255
  36:	7e 07       	cpc	r23, r30
			_device = LSM303DLHC_DEVICE;
  38:	01 f4       	brne	.+0      	; 0x3a <_ZN6LSM30310readMagRegEi+0x3a>
  3a:	f8 01       	movw	r30, r16
  3c:	81 a9       	ldd	r24, Z+49	; 0x31
		}
		else
		{
			// otherwise, assume DLH or DLM (pulled low by default on Pololu boards); query magnetometer WHO_AM_I to differentiate these two
			acc_address = ACC_ADDRESS_SA0_A_LOW;
  3e:	88 23       	and	r24, r24
  40:	01 f4       	brne	.+0      	; 0x42 <_ZN6LSM30310readMagRegEi+0x42>
			_device = (readMagReg(LSM303_WHO_AM_I_M) == 0x3C) ? LSM303DLM_DEVICE : LSM303DLH_DEVICE;
  42:	00 c0       	rjmp	.+0      	; 0x44 <_ZN6LSM30310readMagRegEi+0x44>
  44:	f8 01       	movw	r30, r16
  46:	81 a9       	ldd	r24, Z+49	; 0x31
  48:	88 23       	and	r24, r24
  4a:	01 f4       	brne	.+0      	; 0x4c <_ZN6LSM30310readMagRegEi+0x4c>
  4c:	00 c0       	rjmp	.+0      	; 0x4e <_ZN6LSM30310readMagRegEi+0x4e>
  4e:	f8 01       	movw	r30, r16
  50:	81 a9       	ldd	r24, Z+49	; 0x31
  52:	88 23       	and	r24, r24
  54:	01 f4       	brne	.+0      	; 0x56 <_ZN6LSM30310readMagRegEi+0x56>
		}
		break;
	}
}
  56:	00 c0       	rjmp	.+0      	; 0x58 <_ZN6LSM30310readMagRegEi+0x58>
  58:	f8 01       	movw	r30, r16
  5a:	81 a9       	ldd	r24, Z+49	; 0x31
  5c:	88 23       	and	r24, r24
  5e:	01 f4       	brne	.+0      	; 0x60 <_ZN6LSM30310readMagRegEi+0x60>
  60:	00 c0       	rjmp	.+0      	; 0x62 <_ZN6LSM30310readMagRegEi+0x62>
  62:	c7 e0       	ldi	r28, 0x07	; 7
  64:	d0 e0       	ldi	r29, 0x00	; 0
  66:	00 c0       	rjmp	.+0      	; 0x68 <_ZN6LSM30310readMagRegEi+0x68>
  68:	c8 e0       	ldi	r28, 0x08	; 8
  6a:	d0 e0       	ldi	r29, 0x00	; 0
  6c:	00 c0       	rjmp	.+0      	; 0x6e <_ZN6LSM30310readMagRegEi+0x6e>
  6e:	c5 e0       	ldi	r28, 0x05	; 5
  70:	d0 e0       	ldi	r29, 0x00	; 0
  72:	00 c0       	rjmp	.+0      	; 0x74 <_ZN6LSM30310readMagRegEi+0x74>
  74:	c6 e0       	ldi	r28, 0x06	; 6
  76:	d0 e0       	ldi	r29, 0x00	; 0
  78:	80 e0       	ldi	r24, 0x00	; 0
  7a:	90 e0       	ldi	r25, 0x00	; 0
  7c:	6e e1       	ldi	r22, 0x1E	; 30
  7e:	70 e0       	ldi	r23, 0x00	; 0
  80:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM30310readMagRegEi>
  84:	80 e0       	ldi	r24, 0x00	; 0
  86:	90 e0       	ldi	r25, 0x00	; 0
  88:	be 01       	movw	r22, r28
  8a:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM30310readMagRegEi>
  8e:	80 e0       	ldi	r24, 0x00	; 0
  90:	90 e0       	ldi	r25, 0x00	; 0
  92:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM30310readMagRegEi>
  96:	f8 01       	movw	r30, r16
  98:	80 ab       	std	Z+48, r24	; 0x30
  9a:	80 e0       	ldi	r24, 0x00	; 0
  9c:	90 e0       	ldi	r25, 0x00	; 0
  9e:	6e e1       	ldi	r22, 0x1E	; 30
  a0:	70 e0       	ldi	r23, 0x00	; 0
  a2:	41 e0       	ldi	r20, 0x01	; 1
  a4:	50 e0       	ldi	r21, 0x00	; 0
  a6:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM30310readMagRegEi>
  aa:	80 e0       	ldi	r24, 0x00	; 0
  ac:	90 e0       	ldi	r25, 0x00	; 0
  ae:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM30310readMagRegEi>
  b2:	08 2f       	mov	r16, r24
  b4:	80 e0       	ldi	r24, 0x00	; 0
  b6:	90 e0       	ldi	r25, 0x00	; 0
  b8:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM30310readMagRegEi>
  bc:	80 2f       	mov	r24, r16
  be:	df 91       	pop	r29
  c0:	cf 91       	pop	r28
  c2:	1f 91       	pop	r17
  c4:	0f 91       	pop	r16
  c6:	08 95       	ret

Disassembly of section .text._ZN6LSM30310setMagGainENS_7magGainE:

00000000 <_ZN6LSM30310setMagGainENS_7magGainE>:
{
	return io_timeout;
}

void LSM303::init(byte device, byte sa0_a)
{  
   0:	1f 93       	push	r17
   2:	cf 93       	push	r28
   4:	df 93       	push	r29
	_device = device;
   6:	16 2f       	mov	r17, r22
	switch (_device)
   8:	c0 e0       	ldi	r28, 0x00	; 0
   a:	d0 e0       	ldi	r29, 0x00	; 0
   c:	ce 01       	movw	r24, r28
   e:	6e e1       	ldi	r22, 0x1E	; 30
  10:	70 e0       	ldi	r23, 0x00	; 0
	{
	case LSM303DLH_DEVICE:
	case LSM303DLM_DEVICE:
		if (sa0_a == LSM303_SA0_A_LOW)
  12:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM30310setMagGainENS_7magGainE>
			acc_address = ACC_ADDRESS_SA0_A_LOW;
		else if (sa0_a == LSM303_SA0_A_HIGH)
  16:	ce 01       	movw	r24, r28
  18:	61 e0       	ldi	r22, 0x01	; 1
			acc_address = ACC_ADDRESS_SA0_A_HIGH;
		else
			acc_address = (detectSA0_A() == LSM303_SA0_A_HIGH) ? ACC_ADDRESS_SA0_A_HIGH : ACC_ADDRESS_SA0_A_LOW;
  1a:	70 e0       	ldi	r23, 0x00	; 0
  1c:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM30310setMagGainENS_7magGainE>
  20:	ce 01       	movw	r24, r28
  22:	61 2f       	mov	r22, r17
  24:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM30310setMagGainENS_7magGainE>
		break;

	case LSM303DLHC_DEVICE:
		acc_address = ACC_ADDRESS_SA0_A_HIGH;
  28:	ce 01       	movw	r24, r28
		break;
  2a:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM30310setMagGainENS_7magGainE>

	default:
		// try to auto-detect device
		if (detectSA0_A() == LSM303_SA0_A_HIGH)
  2e:	df 91       	pop	r29
  30:	cf 91       	pop	r28
  32:	1f 91       	pop	r17
		{
			// if device responds on 0011001b (SA0_A is high), assume DLHC
			acc_address = ACC_ADDRESS_SA0_A_HIGH;
  34:	08 95       	ret

Disassembly of section .text._ZN6LSM3037readAccEv:

00000000 <_ZN6LSM3037readAccEv>:
{
	return io_timeout;
}

void LSM303::init(byte device, byte sa0_a)
{  
   0:	cf 92       	push	r12
   2:	df 92       	push	r13
   4:	ef 92       	push	r14
	_device = device;
   6:	ff 92       	push	r15
	switch (_device)
   8:	0f 93       	push	r16
   a:	1f 93       	push	r17
   c:	cf 93       	push	r28
   e:	df 93       	push	r29
  10:	ec 01       	movw	r28, r24
	{
	case LSM303DLH_DEVICE:
	case LSM303DLM_DEVICE:
		if (sa0_a == LSM303_SA0_A_LOW)
  12:	80 e0       	ldi	r24, 0x00	; 0
  14:	90 e0       	ldi	r25, 0x00	; 0
			acc_address = ACC_ADDRESS_SA0_A_LOW;
		else if (sa0_a == LSM303_SA0_A_HIGH)
  16:	6a a9       	ldd	r22, Y+50	; 0x32
  18:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM3037readAccEv>
			acc_address = ACC_ADDRESS_SA0_A_HIGH;
		else
			acc_address = (detectSA0_A() == LSM303_SA0_A_HIGH) ? ACC_ADDRESS_SA0_A_HIGH : ACC_ADDRESS_SA0_A_LOW;
  1c:	80 e0       	ldi	r24, 0x00	; 0
  1e:	90 e0       	ldi	r25, 0x00	; 0
  20:	68 ea       	ldi	r22, 0xA8	; 168
  22:	70 e0       	ldi	r23, 0x00	; 0
  24:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM3037readAccEv>
		break;

	case LSM303DLHC_DEVICE:
		acc_address = ACC_ADDRESS_SA0_A_HIGH;
  28:	80 e0       	ldi	r24, 0x00	; 0
		break;
  2a:	90 e0       	ldi	r25, 0x00	; 0

	default:
		// try to auto-detect device
		if (detectSA0_A() == LSM303_SA0_A_HIGH)
  2c:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM3037readAccEv>
  30:	88 ab       	std	Y+48, r24	; 0x30
  32:	80 e0       	ldi	r24, 0x00	; 0
		{
			// if device responds on 0011001b (SA0_A is high), assume DLHC
			acc_address = ACC_ADDRESS_SA0_A_HIGH;
  34:	90 e0       	ldi	r25, 0x00	; 0
  36:	6a a9       	ldd	r22, Y+50	; 0x32
			_device = LSM303DLHC_DEVICE;
  38:	46 e0       	ldi	r20, 0x06	; 6
  3a:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM3037readAccEv>
		}
		else
		{
			// otherwise, assume DLH or DLM (pulled low by default on Pololu boards); query magnetometer WHO_AM_I to differentiate these two
			acc_address = ACC_ADDRESS_SA0_A_LOW;
  3e:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM3037readAccEv>
			_device = (readMagReg(LSM303_WHO_AM_I_M) == 0x3C) ? LSM303DLM_DEVICE : LSM303DLH_DEVICE;
  42:	8b 01       	movw	r16, r22
  44:	1d aa       	std	Y+53, r1	; 0x35
  46:	00 c0       	rjmp	.+0      	; 0x48 <_ZN6LSM3037readAccEv+0x48>
  48:	8b a9       	ldd	r24, Y+51	; 0x33
  4a:	9c a9       	ldd	r25, Y+52	; 0x34
  4c:	00 97       	sbiw	r24, 0x00	; 0
  4e:	01 f0       	breq	.+0      	; 0x50 <_ZN6LSM3037readAccEv+0x50>
  50:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM3037readAccEv>
  54:	60 1b       	sub	r22, r16
		}
		break;
	}
}
  56:	71 0b       	sbc	r23, r17
  58:	8b a9       	ldd	r24, Y+51	; 0x33
  5a:	9c a9       	ldd	r25, Y+52	; 0x34
  5c:	86 17       	cp	r24, r22
  5e:	97 07       	cpc	r25, r23
  60:	00 f4       	brcc	.+0      	; 0x62 <_ZN6LSM3037readAccEv+0x62>
  62:	81 e0       	ldi	r24, 0x01	; 1
  64:	8d ab       	std	Y+53, r24	; 0x35
  66:	00 c0       	rjmp	.+0      	; 0x68 <_ZN6LSM3037readAccEv+0x68>
  68:	80 e0       	ldi	r24, 0x00	; 0
  6a:	90 e0       	ldi	r25, 0x00	; 0
  6c:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM3037readAccEv>
  70:	86 30       	cpi	r24, 0x06	; 6
  72:	91 05       	cpc	r25, r1
  74:	04 f0       	brlt	.+0      	; 0x76 <_ZN6LSM3037readAccEv+0x76>
  76:	80 e0       	ldi	r24, 0x00	; 0
  78:	90 e0       	ldi	r25, 0x00	; 0
  7a:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM3037readAccEv>
  7e:	d8 2e       	mov	r13, r24
  80:	80 e0       	ldi	r24, 0x00	; 0
  82:	90 e0       	ldi	r25, 0x00	; 0
  84:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM3037readAccEv>
  88:	c8 2e       	mov	r12, r24
  8a:	80 e0       	ldi	r24, 0x00	; 0
  8c:	90 e0       	ldi	r25, 0x00	; 0
  8e:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM3037readAccEv>
  92:	f8 2e       	mov	r15, r24
  94:	80 e0       	ldi	r24, 0x00	; 0
  96:	90 e0       	ldi	r25, 0x00	; 0
  98:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM3037readAccEv>
  9c:	e8 2e       	mov	r14, r24
  9e:	80 e0       	ldi	r24, 0x00	; 0
  a0:	90 e0       	ldi	r25, 0x00	; 0
  a2:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM3037readAccEv>
  a6:	08 2f       	mov	r16, r24
  a8:	80 e0       	ldi	r24, 0x00	; 0
  aa:	90 e0       	ldi	r25, 0x00	; 0
  ac:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM3037readAccEv>
  b0:	18 2f       	mov	r17, r24
  b2:	3c 2d       	mov	r19, r12
  b4:	20 e0       	ldi	r18, 0x00	; 0
  b6:	6d 2d       	mov	r22, r13
  b8:	70 e0       	ldi	r23, 0x00	; 0
  ba:	62 2b       	or	r22, r18
  bc:	73 2b       	or	r23, r19
  be:	34 e0       	ldi	r19, 0x04	; 4
  c0:	75 95       	asr	r23
  c2:	67 95       	ror	r22
  c4:	3a 95       	dec	r19
  c6:	01 f4       	brne	.+0      	; 0xc8 <_ZN6LSM3037readAccEv+0xc8>
  c8:	88 27       	eor	r24, r24
  ca:	77 fd       	sbrc	r23, 7
  cc:	80 95       	com	r24
  ce:	98 2f       	mov	r25, r24
  d0:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM3037readAccEv>
  d4:	68 83       	st	Y, r22
  d6:	79 83       	std	Y+1, r23	; 0x01
  d8:	8a 83       	std	Y+2, r24	; 0x02
  da:	9b 83       	std	Y+3, r25	; 0x03
  dc:	9e 2d       	mov	r25, r14
  de:	80 e0       	ldi	r24, 0x00	; 0
  e0:	6f 2d       	mov	r22, r15
  e2:	70 e0       	ldi	r23, 0x00	; 0
  e4:	68 2b       	or	r22, r24
  e6:	79 2b       	or	r23, r25
  e8:	24 e0       	ldi	r18, 0x04	; 4
  ea:	75 95       	asr	r23
  ec:	67 95       	ror	r22
  ee:	2a 95       	dec	r18
  f0:	01 f4       	brne	.+0      	; 0xf2 <_ZN6LSM3037readAccEv+0xf2>
  f2:	88 27       	eor	r24, r24
  f4:	77 fd       	sbrc	r23, 7
  f6:	80 95       	com	r24
  f8:	98 2f       	mov	r25, r24
  fa:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM3037readAccEv>
  fe:	6c 83       	std	Y+4, r22	; 0x04
 100:	7d 83       	std	Y+5, r23	; 0x05
 102:	8e 83       	std	Y+6, r24	; 0x06
 104:	9f 83       	std	Y+7, r25	; 0x07
 106:	91 2f       	mov	r25, r17
 108:	80 e0       	ldi	r24, 0x00	; 0
 10a:	60 2f       	mov	r22, r16
 10c:	70 e0       	ldi	r23, 0x00	; 0
 10e:	68 2b       	or	r22, r24
 110:	79 2b       	or	r23, r25
 112:	94 e0       	ldi	r25, 0x04	; 4
 114:	75 95       	asr	r23
 116:	67 95       	ror	r22
 118:	9a 95       	dec	r25
 11a:	01 f4       	brne	.+0      	; 0x11c <_ZN6LSM3037readAccEv+0x11c>
 11c:	88 27       	eor	r24, r24
 11e:	77 fd       	sbrc	r23, 7
 120:	80 95       	com	r24
 122:	98 2f       	mov	r25, r24
 124:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM3037readAccEv>
 128:	68 87       	std	Y+8, r22	; 0x08
 12a:	79 87       	std	Y+9, r23	; 0x09
 12c:	8a 87       	std	Y+10, r24	; 0x0a
 12e:	9b 87       	std	Y+11, r25	; 0x0b
 130:	df 91       	pop	r29
 132:	cf 91       	pop	r28
 134:	1f 91       	pop	r17
 136:	0f 91       	pop	r16
 138:	ff 90       	pop	r15
 13a:	ef 90       	pop	r14
 13c:	df 90       	pop	r13
 13e:	cf 90       	pop	r12
 140:	08 95       	ret

Disassembly of section .text._ZN6LSM3037readMagEv:

00000000 <_ZN6LSM3037readMagEv>:
{
	return io_timeout;
}

void LSM303::init(byte device, byte sa0_a)
{  
   0:	cf 92       	push	r12
   2:	df 92       	push	r13
   4:	ef 92       	push	r14
	_device = device;
   6:	ff 92       	push	r15
	switch (_device)
   8:	0f 93       	push	r16
   a:	1f 93       	push	r17
   c:	cf 93       	push	r28
   e:	df 93       	push	r29
  10:	ec 01       	movw	r28, r24
	{
	case LSM303DLH_DEVICE:
	case LSM303DLM_DEVICE:
		if (sa0_a == LSM303_SA0_A_LOW)
  12:	80 e0       	ldi	r24, 0x00	; 0
  14:	90 e0       	ldi	r25, 0x00	; 0
			acc_address = ACC_ADDRESS_SA0_A_LOW;
		else if (sa0_a == LSM303_SA0_A_HIGH)
  16:	6e e1       	ldi	r22, 0x1E	; 30
  18:	70 e0       	ldi	r23, 0x00	; 0
			acc_address = ACC_ADDRESS_SA0_A_HIGH;
		else
			acc_address = (detectSA0_A() == LSM303_SA0_A_HIGH) ? ACC_ADDRESS_SA0_A_HIGH : ACC_ADDRESS_SA0_A_LOW;
  1a:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM3037readMagEv>
  1e:	80 e0       	ldi	r24, 0x00	; 0
  20:	90 e0       	ldi	r25, 0x00	; 0
  22:	63 e0       	ldi	r22, 0x03	; 3
  24:	70 e0       	ldi	r23, 0x00	; 0
		break;

	case LSM303DLHC_DEVICE:
		acc_address = ACC_ADDRESS_SA0_A_HIGH;
  26:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM3037readMagEv>
		break;
  2a:	80 e0       	ldi	r24, 0x00	; 0

	default:
		// try to auto-detect device
		if (detectSA0_A() == LSM303_SA0_A_HIGH)
  2c:	90 e0       	ldi	r25, 0x00	; 0
  2e:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM3037readMagEv>
  32:	88 ab       	std	Y+48, r24	; 0x30
		{
			// if device responds on 0011001b (SA0_A is high), assume DLHC
			acc_address = ACC_ADDRESS_SA0_A_HIGH;
  34:	80 e0       	ldi	r24, 0x00	; 0
  36:	90 e0       	ldi	r25, 0x00	; 0
			_device = LSM303DLHC_DEVICE;
  38:	6e e1       	ldi	r22, 0x1E	; 30
  3a:	70 e0       	ldi	r23, 0x00	; 0
  3c:	46 e0       	ldi	r20, 0x06	; 6
		}
		else
		{
			// otherwise, assume DLH or DLM (pulled low by default on Pololu boards); query magnetometer WHO_AM_I to differentiate these two
			acc_address = ACC_ADDRESS_SA0_A_LOW;
  3e:	50 e0       	ldi	r21, 0x00	; 0
  40:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM3037readMagEv>
			_device = (readMagReg(LSM303_WHO_AM_I_M) == 0x3C) ? LSM303DLM_DEVICE : LSM303DLH_DEVICE;
  44:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM3037readMagEv>
  48:	8b 01       	movw	r16, r22
  4a:	1d aa       	std	Y+53, r1	; 0x35
  4c:	00 c0       	rjmp	.+0      	; 0x4e <_ZN6LSM3037readMagEv+0x4e>
  4e:	8b a9       	ldd	r24, Y+51	; 0x33
  50:	9c a9       	ldd	r25, Y+52	; 0x34
  52:	00 97       	sbiw	r24, 0x00	; 0
  54:	01 f0       	breq	.+0      	; 0x56 <_ZN6LSM3037readMagEv+0x56>
		}
		break;
	}
}
  56:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM3037readMagEv>
  5a:	60 1b       	sub	r22, r16
  5c:	71 0b       	sbc	r23, r17
  5e:	8b a9       	ldd	r24, Y+51	; 0x33
  60:	9c a9       	ldd	r25, Y+52	; 0x34
  62:	86 17       	cp	r24, r22
  64:	97 07       	cpc	r25, r23
  66:	00 f4       	brcc	.+0      	; 0x68 <_ZN6LSM3037readMagEv+0x68>
  68:	81 e0       	ldi	r24, 0x01	; 1
  6a:	8d ab       	std	Y+53, r24	; 0x35
  6c:	00 c0       	rjmp	.+0      	; 0x6e <_ZN6LSM3037readMagEv+0x6e>
  6e:	80 e0       	ldi	r24, 0x00	; 0
  70:	90 e0       	ldi	r25, 0x00	; 0
  72:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM3037readMagEv>
  76:	86 30       	cpi	r24, 0x06	; 6
  78:	91 05       	cpc	r25, r1
  7a:	04 f0       	brlt	.+0      	; 0x7c <_ZN6LSM3037readMagEv+0x7c>
  7c:	80 e0       	ldi	r24, 0x00	; 0
  7e:	90 e0       	ldi	r25, 0x00	; 0
  80:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM3037readMagEv>
  84:	c8 2e       	mov	r12, r24
  86:	80 e0       	ldi	r24, 0x00	; 0
  88:	90 e0       	ldi	r25, 0x00	; 0
  8a:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM3037readMagEv>
  8e:	d8 2e       	mov	r13, r24
  90:	89 a9       	ldd	r24, Y+49	; 0x31
  92:	88 23       	and	r24, r24
  94:	01 f4       	brne	.+0      	; 0x96 <_ZN6LSM3037readMagEv+0x96>
  96:	80 e0       	ldi	r24, 0x00	; 0
  98:	90 e0       	ldi	r25, 0x00	; 0
  9a:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM3037readMagEv>
  9e:	e8 2e       	mov	r14, r24
  a0:	80 e0       	ldi	r24, 0x00	; 0
  a2:	90 e0       	ldi	r25, 0x00	; 0
  a4:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM3037readMagEv>
  a8:	f8 2e       	mov	r15, r24
  aa:	80 e0       	ldi	r24, 0x00	; 0
  ac:	90 e0       	ldi	r25, 0x00	; 0
  ae:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM3037readMagEv>
  b2:	18 2f       	mov	r17, r24
  b4:	80 e0       	ldi	r24, 0x00	; 0
  b6:	90 e0       	ldi	r25, 0x00	; 0
  b8:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM3037readMagEv>
  bc:	08 2f       	mov	r16, r24
  be:	00 c0       	rjmp	.+0      	; 0xc0 <_ZN6LSM3037readMagEv+0xc0>
  c0:	80 e0       	ldi	r24, 0x00	; 0
  c2:	90 e0       	ldi	r25, 0x00	; 0
  c4:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM3037readMagEv>
  c8:	18 2f       	mov	r17, r24
  ca:	80 e0       	ldi	r24, 0x00	; 0
  cc:	90 e0       	ldi	r25, 0x00	; 0
  ce:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM3037readMagEv>
  d2:	08 2f       	mov	r16, r24
  d4:	80 e0       	ldi	r24, 0x00	; 0
  d6:	90 e0       	ldi	r25, 0x00	; 0
  d8:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM3037readMagEv>
  dc:	e8 2e       	mov	r14, r24
  de:	80 e0       	ldi	r24, 0x00	; 0
  e0:	90 e0       	ldi	r25, 0x00	; 0
  e2:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM3037readMagEv>
  e6:	f8 2e       	mov	r15, r24
  e8:	3c 2d       	mov	r19, r12
  ea:	20 e0       	ldi	r18, 0x00	; 0
  ec:	6d 2d       	mov	r22, r13
  ee:	70 e0       	ldi	r23, 0x00	; 0
  f0:	62 2b       	or	r22, r18
  f2:	73 2b       	or	r23, r19
  f4:	88 27       	eor	r24, r24
  f6:	77 fd       	sbrc	r23, 7
  f8:	80 95       	com	r24
  fa:	98 2f       	mov	r25, r24
  fc:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM3037readMagEv>
 100:	6c 87       	std	Y+12, r22	; 0x0c
 102:	7d 87       	std	Y+13, r23	; 0x0d
 104:	8e 87       	std	Y+14, r24	; 0x0e
 106:	9f 87       	std	Y+15, r25	; 0x0f
 108:	9e 2d       	mov	r25, r14
 10a:	80 e0       	ldi	r24, 0x00	; 0
 10c:	6f 2d       	mov	r22, r15
 10e:	70 e0       	ldi	r23, 0x00	; 0
 110:	68 2b       	or	r22, r24
 112:	79 2b       	or	r23, r25
 114:	88 27       	eor	r24, r24
 116:	77 fd       	sbrc	r23, 7
 118:	80 95       	com	r24
 11a:	98 2f       	mov	r25, r24
 11c:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM3037readMagEv>
 120:	68 8b       	std	Y+16, r22	; 0x10
 122:	79 8b       	std	Y+17, r23	; 0x11
 124:	8a 8b       	std	Y+18, r24	; 0x12
 126:	9b 8b       	std	Y+19, r25	; 0x13
 128:	91 2f       	mov	r25, r17
 12a:	80 e0       	ldi	r24, 0x00	; 0
 12c:	60 2f       	mov	r22, r16
 12e:	70 e0       	ldi	r23, 0x00	; 0
 130:	68 2b       	or	r22, r24
 132:	79 2b       	or	r23, r25
 134:	88 27       	eor	r24, r24
 136:	77 fd       	sbrc	r23, 7
 138:	80 95       	com	r24
 13a:	98 2f       	mov	r25, r24
 13c:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM3037readMagEv>
 140:	6c 8b       	std	Y+20, r22	; 0x14
 142:	7d 8b       	std	Y+21, r23	; 0x15
 144:	8e 8b       	std	Y+22, r24	; 0x16
 146:	9f 8b       	std	Y+23, r25	; 0x17
 148:	df 91       	pop	r29
 14a:	cf 91       	pop	r28
 14c:	1f 91       	pop	r17
 14e:	0f 91       	pop	r16
 150:	ff 90       	pop	r15
 152:	ef 90       	pop	r14
 154:	df 90       	pop	r13
 156:	cf 90       	pop	r12
 158:	08 95       	ret

Disassembly of section .text._ZN6LSM3034readEv:

00000000 <_ZN6LSM3034readEv>:
{
	return io_timeout;
}

void LSM303::init(byte device, byte sa0_a)
{  
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	ec 01       	movw	r28, r24
	_device = device;
   6:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM3034readEv>
	switch (_device)
   a:	ce 01       	movw	r24, r28
   c:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM3034readEv>
  10:	df 91       	pop	r29
	{
	case LSM303DLH_DEVICE:
	case LSM303DLM_DEVICE:
		if (sa0_a == LSM303_SA0_A_LOW)
  12:	cf 91       	pop	r28
  14:	08 95       	ret

Disassembly of section .text._ZN6LSM30312vector_crossEPKNS_6vectorES2_PS0_:

00000000 <_ZN6LSM30312vector_crossEPKNS_6vectorES2_PS0_>:
{
	return io_timeout;
}

void LSM303::init(byte device, byte sa0_a)
{  
   0:	2f 92       	push	r2
   2:	3f 92       	push	r3
   4:	4f 92       	push	r4
	_device = device;
   6:	5f 92       	push	r5
	switch (_device)
   8:	6f 92       	push	r6
   a:	7f 92       	push	r7
   c:	8f 92       	push	r8
   e:	9f 92       	push	r9
  10:	af 92       	push	r10
	{
	case LSM303DLH_DEVICE:
	case LSM303DLM_DEVICE:
		if (sa0_a == LSM303_SA0_A_LOW)
  12:	bf 92       	push	r11
  14:	cf 92       	push	r12
			acc_address = ACC_ADDRESS_SA0_A_LOW;
		else if (sa0_a == LSM303_SA0_A_HIGH)
  16:	df 92       	push	r13
  18:	ef 92       	push	r14
			acc_address = ACC_ADDRESS_SA0_A_HIGH;
		else
			acc_address = (detectSA0_A() == LSM303_SA0_A_HIGH) ? ACC_ADDRESS_SA0_A_HIGH : ACC_ADDRESS_SA0_A_LOW;
  1a:	ff 92       	push	r15
  1c:	0f 93       	push	r16
  1e:	1f 93       	push	r17
  20:	df 93       	push	r29
  22:	cf 93       	push	r28
  24:	00 d0       	rcall	.+0      	; 0x26 <_ZN6LSM30312vector_crossEPKNS_6vectorES2_PS0_+0x26>
		break;

	case LSM303DLHC_DEVICE:
		acc_address = ACC_ADDRESS_SA0_A_HIGH;
  26:	00 d0       	rcall	.+0      	; 0x28 <_ZN6LSM30312vector_crossEPKNS_6vectorES2_PS0_+0x28>
  28:	00 d0       	rcall	.+0      	; 0x2a <_ZN6LSM30312vector_crossEPKNS_6vectorES2_PS0_+0x2a>
		break;
  2a:	cd b7       	in	r28, 0x3d	; 61

	default:
		// try to auto-detect device
		if (detectSA0_A() == LSM303_SA0_A_HIGH)
  2c:	de b7       	in	r29, 0x3e	; 62
  2e:	8c 01       	movw	r16, r24
  30:	7e 83       	std	Y+6, r23	; 0x06
  32:	6d 83       	std	Y+5, r22	; 0x05
		{
			// if device responds on 0011001b (SA0_A is high), assume DLHC
			acc_address = ACC_ADDRESS_SA0_A_HIGH;
  34:	1a 01       	movw	r2, r20
  36:	db 01       	movw	r26, r22
			_device = LSM303DLHC_DEVICE;
  38:	18 96       	adiw	r26, 0x08	; 8
  3a:	4d 90       	ld	r4, X+
  3c:	5d 90       	ld	r5, X+
		}
		else
		{
			// otherwise, assume DLH or DLM (pulled low by default on Pololu boards); query magnetometer WHO_AM_I to differentiate these two
			acc_address = ACC_ADDRESS_SA0_A_LOW;
  3e:	6d 90       	ld	r6, X+
  40:	7c 90       	ld	r7, X
			_device = (readMagReg(LSM303_WHO_AM_I_M) == 0x3C) ? LSM303DLM_DEVICE : LSM303DLH_DEVICE;
  42:	1b 97       	sbiw	r26, 0x0b	; 11
  44:	fc 01       	movw	r30, r24
  46:	c0 84       	ldd	r12, Z+8	; 0x08
  48:	d1 84       	ldd	r13, Z+9	; 0x09
  4a:	e2 84       	ldd	r14, Z+10	; 0x0a
  4c:	f3 84       	ldd	r15, Z+11	; 0x0b
  4e:	c3 01       	movw	r24, r6
  50:	b2 01       	movw	r22, r4
  52:	24 81       	ldd	r18, Z+4	; 0x04
  54:	35 81       	ldd	r19, Z+5	; 0x05
		}
		break;
	}
}
  56:	46 81       	ldd	r20, Z+6	; 0x06
  58:	57 81       	ldd	r21, Z+7	; 0x07
  5a:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM30312vector_crossEPKNS_6vectorES2_PS0_>
  5e:	4b 01       	movw	r8, r22
  60:	5c 01       	movw	r10, r24
  62:	c7 01       	movw	r24, r14
  64:	b6 01       	movw	r22, r12
  66:	ad 81       	ldd	r26, Y+5	; 0x05
  68:	be 81       	ldd	r27, Y+6	; 0x06
  6a:	14 96       	adiw	r26, 0x04	; 4
  6c:	2d 91       	ld	r18, X+
  6e:	3d 91       	ld	r19, X+
  70:	4d 91       	ld	r20, X+
  72:	5c 91       	ld	r21, X
  74:	17 97       	sbiw	r26, 0x07	; 7
  76:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM30312vector_crossEPKNS_6vectorES2_PS0_>
  7a:	9b 01       	movw	r18, r22
  7c:	ac 01       	movw	r20, r24
  7e:	c5 01       	movw	r24, r10
  80:	b4 01       	movw	r22, r8
  82:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM30312vector_crossEPKNS_6vectorES2_PS0_>
  86:	f1 01       	movw	r30, r2
  88:	60 83       	st	Z, r22
  8a:	71 83       	std	Z+1, r23	; 0x01
  8c:	82 83       	std	Z+2, r24	; 0x02
  8e:	93 83       	std	Z+3, r25	; 0x03
  90:	ad 81       	ldd	r26, Y+5	; 0x05
  92:	be 81       	ldd	r27, Y+6	; 0x06
  94:	8d 91       	ld	r24, X+
  96:	9d 91       	ld	r25, X+
  98:	0d 90       	ld	r0, X+
  9a:	bc 91       	ld	r27, X
  9c:	a0 2d       	mov	r26, r0
  9e:	89 83       	std	Y+1, r24	; 0x01
  a0:	9a 83       	std	Y+2, r25	; 0x02
  a2:	ab 83       	std	Y+3, r26	; 0x03
  a4:	bc 83       	std	Y+4, r27	; 0x04
  a6:	f8 01       	movw	r30, r16
  a8:	80 80       	ld	r8, Z
  aa:	91 80       	ldd	r9, Z+1	; 0x01
  ac:	a2 80       	ldd	r10, Z+2	; 0x02
  ae:	b3 80       	ldd	r11, Z+3	; 0x03
  b0:	c7 01       	movw	r24, r14
  b2:	b6 01       	movw	r22, r12
  b4:	29 81       	ldd	r18, Y+1	; 0x01
  b6:	3a 81       	ldd	r19, Y+2	; 0x02
  b8:	4b 81       	ldd	r20, Y+3	; 0x03
  ba:	5c 81       	ldd	r21, Y+4	; 0x04
  bc:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM30312vector_crossEPKNS_6vectorES2_PS0_>
  c0:	6b 01       	movw	r12, r22
  c2:	7c 01       	movw	r14, r24
  c4:	c5 01       	movw	r24, r10
  c6:	b4 01       	movw	r22, r8
  c8:	a3 01       	movw	r20, r6
  ca:	92 01       	movw	r18, r4
  cc:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM30312vector_crossEPKNS_6vectorES2_PS0_>
  d0:	9b 01       	movw	r18, r22
  d2:	ac 01       	movw	r20, r24
  d4:	c7 01       	movw	r24, r14
  d6:	b6 01       	movw	r22, r12
  d8:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM30312vector_crossEPKNS_6vectorES2_PS0_>
  dc:	d1 01       	movw	r26, r2
  de:	14 96       	adiw	r26, 0x04	; 4
  e0:	6d 93       	st	X+, r22
  e2:	7d 93       	st	X+, r23
  e4:	8d 93       	st	X+, r24
  e6:	9c 93       	st	X, r25
  e8:	17 97       	sbiw	r26, 0x07	; 7
  ea:	c5 01       	movw	r24, r10
  ec:	b4 01       	movw	r22, r8
  ee:	ed 81       	ldd	r30, Y+5	; 0x05
  f0:	fe 81       	ldd	r31, Y+6	; 0x06
  f2:	24 81       	ldd	r18, Z+4	; 0x04
  f4:	35 81       	ldd	r19, Z+5	; 0x05
  f6:	46 81       	ldd	r20, Z+6	; 0x06
  f8:	57 81       	ldd	r21, Z+7	; 0x07
  fa:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM30312vector_crossEPKNS_6vectorES2_PS0_>
  fe:	6b 01       	movw	r12, r22
 100:	7c 01       	movw	r14, r24
 102:	69 81       	ldd	r22, Y+1	; 0x01
 104:	7a 81       	ldd	r23, Y+2	; 0x02
 106:	8b 81       	ldd	r24, Y+3	; 0x03
 108:	9c 81       	ldd	r25, Y+4	; 0x04
 10a:	d8 01       	movw	r26, r16
 10c:	14 96       	adiw	r26, 0x04	; 4
 10e:	2d 91       	ld	r18, X+
 110:	3d 91       	ld	r19, X+
 112:	4d 91       	ld	r20, X+
 114:	5c 91       	ld	r21, X
 116:	17 97       	sbiw	r26, 0x07	; 7
 118:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM30312vector_crossEPKNS_6vectorES2_PS0_>
 11c:	9b 01       	movw	r18, r22
 11e:	ac 01       	movw	r20, r24
 120:	c7 01       	movw	r24, r14
 122:	b6 01       	movw	r22, r12
 124:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM30312vector_crossEPKNS_6vectorES2_PS0_>
 128:	f1 01       	movw	r30, r2
 12a:	60 87       	std	Z+8, r22	; 0x08
 12c:	71 87       	std	Z+9, r23	; 0x09
 12e:	82 87       	std	Z+10, r24	; 0x0a
 130:	93 87       	std	Z+11, r25	; 0x0b
 132:	26 96       	adiw	r28, 0x06	; 6
 134:	0f b6       	in	r0, 0x3f	; 63
 136:	f8 94       	cli
 138:	de bf       	out	0x3e, r29	; 62
 13a:	0f be       	out	0x3f, r0	; 63
 13c:	cd bf       	out	0x3d, r28	; 61
 13e:	cf 91       	pop	r28
 140:	df 91       	pop	r29
 142:	1f 91       	pop	r17
 144:	0f 91       	pop	r16
 146:	ff 90       	pop	r15
 148:	ef 90       	pop	r14
 14a:	df 90       	pop	r13
 14c:	cf 90       	pop	r12
 14e:	bf 90       	pop	r11
 150:	af 90       	pop	r10
 152:	9f 90       	pop	r9
 154:	8f 90       	pop	r8
 156:	7f 90       	pop	r7
 158:	6f 90       	pop	r6
 15a:	5f 90       	pop	r5
 15c:	4f 90       	pop	r4
 15e:	3f 90       	pop	r3
 160:	2f 90       	pop	r2
 162:	08 95       	ret

Disassembly of section .text._ZN6LSM30310vector_dotEPKNS_6vectorES2_:

00000000 <_ZN6LSM30310vector_dotEPKNS_6vectorES2_>:
{
	return io_timeout;
}

void LSM303::init(byte device, byte sa0_a)
{  
   0:	cf 92       	push	r12
   2:	df 92       	push	r13
   4:	ef 92       	push	r14
	_device = device;
   6:	ff 92       	push	r15
	switch (_device)
   8:	0f 93       	push	r16
   a:	1f 93       	push	r17
   c:	cf 93       	push	r28
   e:	df 93       	push	r29
  10:	ec 01       	movw	r28, r24
	{
	case LSM303DLH_DEVICE:
	case LSM303DLM_DEVICE:
		if (sa0_a == LSM303_SA0_A_LOW)
  12:	8b 01       	movw	r16, r22
  14:	68 81       	ld	r22, Y
			acc_address = ACC_ADDRESS_SA0_A_LOW;
		else if (sa0_a == LSM303_SA0_A_HIGH)
  16:	79 81       	ldd	r23, Y+1	; 0x01
  18:	8a 81       	ldd	r24, Y+2	; 0x02
			acc_address = ACC_ADDRESS_SA0_A_HIGH;
		else
			acc_address = (detectSA0_A() == LSM303_SA0_A_HIGH) ? ACC_ADDRESS_SA0_A_HIGH : ACC_ADDRESS_SA0_A_LOW;
  1a:	9b 81       	ldd	r25, Y+3	; 0x03
  1c:	f8 01       	movw	r30, r16
  1e:	20 81       	ld	r18, Z
  20:	31 81       	ldd	r19, Z+1	; 0x01
  22:	42 81       	ldd	r20, Z+2	; 0x02
  24:	53 81       	ldd	r21, Z+3	; 0x03
		break;

	case LSM303DLHC_DEVICE:
		acc_address = ACC_ADDRESS_SA0_A_HIGH;
  26:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM30310vector_dotEPKNS_6vectorES2_>
		break;
  2a:	6b 01       	movw	r12, r22

	default:
		// try to auto-detect device
		if (detectSA0_A() == LSM303_SA0_A_HIGH)
  2c:	7c 01       	movw	r14, r24
  2e:	6c 81       	ldd	r22, Y+4	; 0x04
  30:	7d 81       	ldd	r23, Y+5	; 0x05
  32:	8e 81       	ldd	r24, Y+6	; 0x06
		{
			// if device responds on 0011001b (SA0_A is high), assume DLHC
			acc_address = ACC_ADDRESS_SA0_A_HIGH;
  34:	9f 81       	ldd	r25, Y+7	; 0x07
  36:	f8 01       	movw	r30, r16
			_device = LSM303DLHC_DEVICE;
  38:	24 81       	ldd	r18, Z+4	; 0x04
  3a:	35 81       	ldd	r19, Z+5	; 0x05
  3c:	46 81       	ldd	r20, Z+6	; 0x06
		}
		else
		{
			// otherwise, assume DLH or DLM (pulled low by default on Pololu boards); query magnetometer WHO_AM_I to differentiate these two
			acc_address = ACC_ADDRESS_SA0_A_LOW;
  3e:	57 81       	ldd	r21, Z+7	; 0x07
  40:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM30310vector_dotEPKNS_6vectorES2_>
			_device = (readMagReg(LSM303_WHO_AM_I_M) == 0x3C) ? LSM303DLM_DEVICE : LSM303DLH_DEVICE;
  44:	9b 01       	movw	r18, r22
  46:	ac 01       	movw	r20, r24
  48:	c7 01       	movw	r24, r14
  4a:	b6 01       	movw	r22, r12
  4c:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM30310vector_dotEPKNS_6vectorES2_>
  50:	6b 01       	movw	r12, r22
  52:	7c 01       	movw	r14, r24
  54:	68 85       	ldd	r22, Y+8	; 0x08
		}
		break;
	}
}
  56:	79 85       	ldd	r23, Y+9	; 0x09
  58:	8a 85       	ldd	r24, Y+10	; 0x0a
  5a:	9b 85       	ldd	r25, Y+11	; 0x0b
  5c:	f8 01       	movw	r30, r16
  5e:	20 85       	ldd	r18, Z+8	; 0x08
  60:	31 85       	ldd	r19, Z+9	; 0x09
  62:	42 85       	ldd	r20, Z+10	; 0x0a
  64:	53 85       	ldd	r21, Z+11	; 0x0b
  66:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM30310vector_dotEPKNS_6vectorES2_>
  6a:	9b 01       	movw	r18, r22
  6c:	ac 01       	movw	r20, r24
  6e:	c7 01       	movw	r24, r14
  70:	b6 01       	movw	r22, r12
  72:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM30310vector_dotEPKNS_6vectorES2_>
  76:	df 91       	pop	r29
  78:	cf 91       	pop	r28
  7a:	1f 91       	pop	r17
  7c:	0f 91       	pop	r16
  7e:	ff 90       	pop	r15
  80:	ef 90       	pop	r14
  82:	df 90       	pop	r13
  84:	cf 90       	pop	r12
  86:	08 95       	ret

Disassembly of section .text._ZN6LSM30316vector_normalizeEPNS_6vectorE:

00000000 <_ZN6LSM30316vector_normalizeEPNS_6vectorE>:
{
	return io_timeout;
}

void LSM303::init(byte device, byte sa0_a)
{  
   0:	ef 92       	push	r14
   2:	ff 92       	push	r15
   4:	0f 93       	push	r16
	_device = device;
   6:	1f 93       	push	r17
	switch (_device)
   8:	cf 93       	push	r28
   a:	df 93       	push	r29
   c:	ec 01       	movw	r28, r24
   e:	be 01       	movw	r22, r28
  10:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM30316vector_normalizeEPNS_6vectorE>
	{
	case LSM303DLH_DEVICE:
	case LSM303DLM_DEVICE:
		if (sa0_a == LSM303_SA0_A_LOW)
  14:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM30316vector_normalizeEPNS_6vectorE>
			acc_address = ACC_ADDRESS_SA0_A_LOW;
		else if (sa0_a == LSM303_SA0_A_HIGH)
  18:	7b 01       	movw	r14, r22
			acc_address = ACC_ADDRESS_SA0_A_HIGH;
		else
			acc_address = (detectSA0_A() == LSM303_SA0_A_HIGH) ? ACC_ADDRESS_SA0_A_HIGH : ACC_ADDRESS_SA0_A_LOW;
  1a:	8c 01       	movw	r16, r24
  1c:	68 81       	ld	r22, Y
  1e:	79 81       	ldd	r23, Y+1	; 0x01
  20:	8a 81       	ldd	r24, Y+2	; 0x02
  22:	9b 81       	ldd	r25, Y+3	; 0x03
  24:	a8 01       	movw	r20, r16
		break;

	case LSM303DLHC_DEVICE:
		acc_address = ACC_ADDRESS_SA0_A_HIGH;
  26:	97 01       	movw	r18, r14
  28:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM30316vector_normalizeEPNS_6vectorE>
		break;

	default:
		// try to auto-detect device
		if (detectSA0_A() == LSM303_SA0_A_HIGH)
  2c:	68 83       	st	Y, r22
  2e:	79 83       	std	Y+1, r23	; 0x01
  30:	8a 83       	std	Y+2, r24	; 0x02
  32:	9b 83       	std	Y+3, r25	; 0x03
		{
			// if device responds on 0011001b (SA0_A is high), assume DLHC
			acc_address = ACC_ADDRESS_SA0_A_HIGH;
  34:	6c 81       	ldd	r22, Y+4	; 0x04
  36:	7d 81       	ldd	r23, Y+5	; 0x05
			_device = LSM303DLHC_DEVICE;
  38:	8e 81       	ldd	r24, Y+6	; 0x06
  3a:	9f 81       	ldd	r25, Y+7	; 0x07
  3c:	a8 01       	movw	r20, r16
		}
		else
		{
			// otherwise, assume DLH or DLM (pulled low by default on Pololu boards); query magnetometer WHO_AM_I to differentiate these two
			acc_address = ACC_ADDRESS_SA0_A_LOW;
  3e:	97 01       	movw	r18, r14
  40:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM30316vector_normalizeEPNS_6vectorE>
			_device = (readMagReg(LSM303_WHO_AM_I_M) == 0x3C) ? LSM303DLM_DEVICE : LSM303DLH_DEVICE;
  44:	6c 83       	std	Y+4, r22	; 0x04
  46:	7d 83       	std	Y+5, r23	; 0x05
  48:	8e 83       	std	Y+6, r24	; 0x06
  4a:	9f 83       	std	Y+7, r25	; 0x07
  4c:	68 85       	ldd	r22, Y+8	; 0x08
  4e:	79 85       	ldd	r23, Y+9	; 0x09
  50:	8a 85       	ldd	r24, Y+10	; 0x0a
  52:	9b 85       	ldd	r25, Y+11	; 0x0b
  54:	a8 01       	movw	r20, r16
		}
		break;
	}
}
  56:	97 01       	movw	r18, r14
  58:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM30316vector_normalizeEPNS_6vectorE>
  5c:	68 87       	std	Y+8, r22	; 0x08
  5e:	79 87       	std	Y+9, r23	; 0x09
  60:	8a 87       	std	Y+10, r24	; 0x0a
  62:	9b 87       	std	Y+11, r25	; 0x0b
  64:	df 91       	pop	r29
  66:	cf 91       	pop	r28
  68:	1f 91       	pop	r17
  6a:	0f 91       	pop	r16
  6c:	ff 90       	pop	r15
  6e:	ef 90       	pop	r14
  70:	08 95       	ret

Disassembly of section .text._ZN6LSM3037headingENS_6vectorE:

00000000 <_ZN6LSM3037headingENS_6vectorE>:
{
	return io_timeout;
}

void LSM303::init(byte device, byte sa0_a)
{  
   0:	6f 92       	push	r6
   2:	7f 92       	push	r7
   4:	8f 92       	push	r8
	_device = device;
   6:	9f 92       	push	r9
	switch (_device)
   8:	af 92       	push	r10
   a:	bf 92       	push	r11
   c:	cf 92       	push	r12
   e:	df 92       	push	r13
  10:	ef 92       	push	r14
	{
	case LSM303DLH_DEVICE:
	case LSM303DLM_DEVICE:
		if (sa0_a == LSM303_SA0_A_LOW)
  12:	ff 92       	push	r15
  14:	0f 93       	push	r16
			acc_address = ACC_ADDRESS_SA0_A_LOW;
		else if (sa0_a == LSM303_SA0_A_HIGH)
  16:	1f 93       	push	r17
  18:	df 93       	push	r29
			acc_address = ACC_ADDRESS_SA0_A_HIGH;
		else
			acc_address = (detectSA0_A() == LSM303_SA0_A_HIGH) ? ACC_ADDRESS_SA0_A_HIGH : ACC_ADDRESS_SA0_A_LOW;
  1a:	cf 93       	push	r28
  1c:	cd b7       	in	r28, 0x3d	; 61
  1e:	de b7       	in	r29, 0x3e	; 62
  20:	e0 97       	sbiw	r28, 0x30	; 48
  22:	0f b6       	in	r0, 0x3f	; 63
  24:	f8 94       	cli
		break;

	case LSM303DLHC_DEVICE:
		acc_address = ACC_ADDRESS_SA0_A_HIGH;
  26:	de bf       	out	0x3e, r29	; 62
  28:	0f be       	out	0x3f, r0	; 63
		break;
  2a:	cd bf       	out	0x3d, r28	; 61

	default:
		// try to auto-detect device
		if (detectSA0_A() == LSM303_SA0_A_HIGH)
  2c:	5c 01       	movw	r10, r24
  2e:	cd a2       	std	Y+37, r12	; 0x25
  30:	de a2       	std	Y+38, r13	; 0x26
  32:	ef a2       	std	Y+39, r14	; 0x27
		{
			// if device responds on 0011001b (SA0_A is high), assume DLHC
			acc_address = ACC_ADDRESS_SA0_A_HIGH;
  34:	f8 a6       	std	Y+40, r15	; 0x28
  36:	09 a7       	std	Y+41, r16	; 0x29
			_device = LSM303DLHC_DEVICE;
  38:	1a a7       	std	Y+42, r17	; 0x2a
  3a:	2b a7       	std	Y+43, r18	; 0x2b
  3c:	3c a7       	std	Y+44, r19	; 0x2c
		}
		else
		{
			// otherwise, assume DLH or DLM (pulled low by default on Pololu boards); query magnetometer WHO_AM_I to differentiate these two
			acc_address = ACC_ADDRESS_SA0_A_LOW;
  3e:	4d a7       	std	Y+45, r20	; 0x2d
  40:	5e a7       	std	Y+46, r21	; 0x2e
			_device = (readMagReg(LSM303_WHO_AM_I_M) == 0x3C) ? LSM303DLM_DEVICE : LSM303DLH_DEVICE;
  42:	6f a7       	std	Y+47, r22	; 0x2f
  44:	78 ab       	std	Y+48, r23	; 0x30
  46:	fc 01       	movw	r30, r24
  48:	e4 a0       	ldd	r14, Z+36	; 0x24
  4a:	f5 a0       	ldd	r15, Z+37	; 0x25
  4c:	06 a1       	ldd	r16, Z+38	; 0x26
  4e:	17 a1       	ldd	r17, Z+39	; 0x27
  50:	64 85       	ldd	r22, Z+12	; 0x0c
  52:	75 85       	ldd	r23, Z+13	; 0x0d
  54:	86 85       	ldd	r24, Z+14	; 0x0e
		}
		break;
	}
}
  56:	97 85       	ldd	r25, Z+15	; 0x0f
  58:	a8 01       	movw	r20, r16
  5a:	97 01       	movw	r18, r14
  5c:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM3037headingENS_6vectorE>
  60:	3b 01       	movw	r6, r22
  62:	4c 01       	movw	r8, r24
  64:	f5 01       	movw	r30, r10
  66:	60 8d       	ldd	r22, Z+24	; 0x18
  68:	71 8d       	ldd	r23, Z+25	; 0x19
  6a:	82 8d       	ldd	r24, Z+26	; 0x1a
  6c:	93 8d       	ldd	r25, Z+27	; 0x1b
  6e:	a8 01       	movw	r20, r16
  70:	97 01       	movw	r18, r14
  72:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM3037headingENS_6vectorE>
  76:	9b 01       	movw	r18, r22
  78:	ac 01       	movw	r20, r24
  7a:	c4 01       	movw	r24, r8
  7c:	b3 01       	movw	r22, r6
  7e:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM3037headingENS_6vectorE>
  82:	9b 01       	movw	r18, r22
  84:	ac 01       	movw	r20, r24
  86:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM3037headingENS_6vectorE>
  8a:	20 e0       	ldi	r18, 0x00	; 0
  8c:	30 e0       	ldi	r19, 0x00	; 0
  8e:	40 e8       	ldi	r20, 0x80	; 128
  90:	5f e3       	ldi	r21, 0x3F	; 63
  92:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM3037headingENS_6vectorE>
  96:	f5 01       	movw	r30, r10
  98:	64 87       	std	Z+12, r22	; 0x0c
  9a:	75 87       	std	Z+13, r23	; 0x0d
  9c:	86 87       	std	Z+14, r24	; 0x0e
  9e:	97 87       	std	Z+15, r25	; 0x0f
  a0:	e0 a4       	ldd	r14, Z+40	; 0x28
  a2:	f1 a4       	ldd	r15, Z+41	; 0x29
  a4:	02 a5       	ldd	r16, Z+42	; 0x2a
  a6:	13 a5       	ldd	r17, Z+43	; 0x2b
  a8:	60 89       	ldd	r22, Z+16	; 0x10
  aa:	71 89       	ldd	r23, Z+17	; 0x11
  ac:	82 89       	ldd	r24, Z+18	; 0x12
  ae:	93 89       	ldd	r25, Z+19	; 0x13
  b0:	a8 01       	movw	r20, r16
  b2:	97 01       	movw	r18, r14
  b4:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM3037headingENS_6vectorE>
  b8:	3b 01       	movw	r6, r22
  ba:	4c 01       	movw	r8, r24
  bc:	f5 01       	movw	r30, r10
  be:	64 8d       	ldd	r22, Z+28	; 0x1c
  c0:	75 8d       	ldd	r23, Z+29	; 0x1d
  c2:	86 8d       	ldd	r24, Z+30	; 0x1e
  c4:	97 8d       	ldd	r25, Z+31	; 0x1f
  c6:	a8 01       	movw	r20, r16
  c8:	97 01       	movw	r18, r14
  ca:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM3037headingENS_6vectorE>
  ce:	9b 01       	movw	r18, r22
  d0:	ac 01       	movw	r20, r24
  d2:	c4 01       	movw	r24, r8
  d4:	b3 01       	movw	r22, r6
  d6:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM3037headingENS_6vectorE>
  da:	9b 01       	movw	r18, r22
  dc:	ac 01       	movw	r20, r24
  de:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM3037headingENS_6vectorE>
  e2:	20 e0       	ldi	r18, 0x00	; 0
  e4:	30 e0       	ldi	r19, 0x00	; 0
  e6:	40 e8       	ldi	r20, 0x80	; 128
  e8:	5f e3       	ldi	r21, 0x3F	; 63
  ea:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM3037headingENS_6vectorE>
  ee:	f5 01       	movw	r30, r10
  f0:	60 8b       	std	Z+16, r22	; 0x10
  f2:	71 8b       	std	Z+17, r23	; 0x11
  f4:	82 8b       	std	Z+18, r24	; 0x12
  f6:	93 8b       	std	Z+19, r25	; 0x13
  f8:	e4 a4       	ldd	r14, Z+44	; 0x2c
  fa:	f5 a4       	ldd	r15, Z+45	; 0x2d
  fc:	06 a5       	ldd	r16, Z+46	; 0x2e
  fe:	17 a5       	ldd	r17, Z+47	; 0x2f
 100:	64 89       	ldd	r22, Z+20	; 0x14
 102:	75 89       	ldd	r23, Z+21	; 0x15
 104:	86 89       	ldd	r24, Z+22	; 0x16
 106:	97 89       	ldd	r25, Z+23	; 0x17
 108:	a8 01       	movw	r20, r16
 10a:	97 01       	movw	r18, r14
 10c:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM3037headingENS_6vectorE>
 110:	3b 01       	movw	r6, r22
 112:	4c 01       	movw	r8, r24
 114:	f5 01       	movw	r30, r10
 116:	60 a1       	ldd	r22, Z+32	; 0x20
 118:	71 a1       	ldd	r23, Z+33	; 0x21
 11a:	82 a1       	ldd	r24, Z+34	; 0x22
 11c:	93 a1       	ldd	r25, Z+35	; 0x23
 11e:	a8 01       	movw	r20, r16
 120:	97 01       	movw	r18, r14
 122:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM3037headingENS_6vectorE>
 126:	9b 01       	movw	r18, r22
 128:	ac 01       	movw	r20, r24
 12a:	c4 01       	movw	r24, r8
 12c:	b3 01       	movw	r22, r6
 12e:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM3037headingENS_6vectorE>
 132:	9b 01       	movw	r18, r22
 134:	ac 01       	movw	r20, r24
 136:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM3037headingENS_6vectorE>
 13a:	20 e0       	ldi	r18, 0x00	; 0
 13c:	30 e0       	ldi	r19, 0x00	; 0
 13e:	40 e8       	ldi	r20, 0x80	; 128
 140:	5f e3       	ldi	r21, 0x3F	; 63
 142:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM3037headingENS_6vectorE>
 146:	f5 01       	movw	r30, r10
 148:	64 8b       	std	Z+20, r22	; 0x14
 14a:	75 8b       	std	Z+21, r23	; 0x15
 14c:	86 8b       	std	Z+22, r24	; 0x16
 14e:	97 8b       	std	Z+23, r25	; 0x17
 150:	de 01       	movw	r26, r28
 152:	11 96       	adiw	r26, 0x01	; 1
 154:	8c e0       	ldi	r24, 0x0C	; 12
 156:	01 90       	ld	r0, Z+
 158:	0d 92       	st	X+, r0
 15a:	81 50       	subi	r24, 0x01	; 1
 15c:	01 f4       	brne	.+0      	; 0x15e <_ZN6LSM3037headingENS_6vectorE+0x15e>
 15e:	7e 01       	movw	r14, r28
 160:	08 94       	sec
 162:	e1 1c       	adc	r14, r1
 164:	f1 1c       	adc	r15, r1
 166:	c7 01       	movw	r24, r14
 168:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM3037headingENS_6vectorE>
 16c:	8e 01       	movw	r16, r28
 16e:	03 5f       	subi	r16, 0xF3	; 243
 170:	1f 4f       	sbci	r17, 0xFF	; 255
 172:	c5 01       	movw	r24, r10
 174:	0c 96       	adiw	r24, 0x0c	; 12
 176:	b7 01       	movw	r22, r14
 178:	a8 01       	movw	r20, r16
 17a:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM3037headingENS_6vectorE>
 17e:	c8 01       	movw	r24, r16
 180:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM3037headingENS_6vectorE>
 184:	59 e1       	ldi	r21, 0x19	; 25
 186:	c5 2e       	mov	r12, r21
 188:	d1 2c       	mov	r13, r1
 18a:	cc 0e       	add	r12, r28
 18c:	dd 1e       	adc	r13, r29
 18e:	c7 01       	movw	r24, r14
 190:	b8 01       	movw	r22, r16
 192:	a6 01       	movw	r20, r12
 194:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM3037headingENS_6vectorE>
 198:	45 e2       	ldi	r20, 0x25	; 37
 19a:	a4 2e       	mov	r10, r20
 19c:	b1 2c       	mov	r11, r1
 19e:	ac 0e       	add	r10, r28
 1a0:	bd 1e       	adc	r11, r29
 1a2:	c8 01       	movw	r24, r16
 1a4:	b5 01       	movw	r22, r10
 1a6:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM3037headingENS_6vectorE>
 1aa:	7b 01       	movw	r14, r22
 1ac:	8c 01       	movw	r16, r24
 1ae:	c6 01       	movw	r24, r12
 1b0:	b5 01       	movw	r22, r10
 1b2:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM3037headingENS_6vectorE>
 1b6:	9b 01       	movw	r18, r22
 1b8:	ac 01       	movw	r20, r24
 1ba:	c8 01       	movw	r24, r16
 1bc:	b7 01       	movw	r22, r14
 1be:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM3037headingENS_6vectorE>
 1c2:	20 e0       	ldi	r18, 0x00	; 0
 1c4:	30 e0       	ldi	r19, 0x00	; 0
 1c6:	44 e3       	ldi	r20, 0x34	; 52
 1c8:	53 e4       	ldi	r21, 0x43	; 67
 1ca:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM3037headingENS_6vectorE>
 1ce:	2b ed       	ldi	r18, 0xDB	; 219
 1d0:	3f e0       	ldi	r19, 0x0F	; 15
 1d2:	49 e4       	ldi	r20, 0x49	; 73
 1d4:	50 e4       	ldi	r21, 0x40	; 64
 1d6:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM3037headingENS_6vectorE>
 1da:	a6 2e       	mov	r10, r22
 1dc:	c7 2e       	mov	r12, r23
 1de:	e8 2e       	mov	r14, r24
 1e0:	09 2f       	mov	r16, r25
 1e2:	20 e0       	ldi	r18, 0x00	; 0
 1e4:	30 e0       	ldi	r19, 0x00	; 0
 1e6:	a9 01       	movw	r20, r18
 1e8:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM3037headingENS_6vectorE>
 1ec:	87 fd       	sbrc	r24, 7
 1ee:	00 c0       	rjmp	.+0      	; 0x1f0 <_ZN6LSM3037headingENS_6vectorE+0x1f0>
 1f0:	6a 2d       	mov	r22, r10
 1f2:	7c 2d       	mov	r23, r12
 1f4:	8e 2d       	mov	r24, r14
 1f6:	90 2f       	mov	r25, r16
 1f8:	20 e0       	ldi	r18, 0x00	; 0
 1fa:	30 e0       	ldi	r19, 0x00	; 0
 1fc:	40 e0       	ldi	r20, 0x00	; 0
 1fe:	5f e3       	ldi	r21, 0x3F	; 63
 200:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM3037headingENS_6vectorE>
 204:	00 c0       	rjmp	.+0      	; 0x206 <_ZN6LSM3037headingENS_6vectorE+0x206>
 206:	6a 2d       	mov	r22, r10
 208:	7c 2d       	mov	r23, r12
 20a:	8e 2d       	mov	r24, r14
 20c:	90 2f       	mov	r25, r16
 20e:	20 e0       	ldi	r18, 0x00	; 0
 210:	30 e0       	ldi	r19, 0x00	; 0
 212:	40 e0       	ldi	r20, 0x00	; 0
 214:	5f e3       	ldi	r21, 0x3F	; 63
 216:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM3037headingENS_6vectorE>
 21a:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM3037headingENS_6vectorE>
 21e:	77 ff       	sbrs	r23, 7
 220:	00 c0       	rjmp	.+0      	; 0x222 <_ZN6LSM3037headingENS_6vectorE+0x222>
 222:	68 59       	subi	r22, 0x98	; 152
 224:	7e 4f       	sbci	r23, 0xFE	; 254
 226:	cb 01       	movw	r24, r22
 228:	e0 96       	adiw	r28, 0x30	; 48
 22a:	0f b6       	in	r0, 0x3f	; 63
 22c:	f8 94       	cli
 22e:	de bf       	out	0x3e, r29	; 62
 230:	0f be       	out	0x3f, r0	; 63
 232:	cd bf       	out	0x3d, r28	; 61
 234:	cf 91       	pop	r28
 236:	df 91       	pop	r29
 238:	1f 91       	pop	r17
 23a:	0f 91       	pop	r16
 23c:	ff 90       	pop	r15
 23e:	ef 90       	pop	r14
 240:	df 90       	pop	r13
 242:	cf 90       	pop	r12
 244:	bf 90       	pop	r11
 246:	af 90       	pop	r10
 248:	9f 90       	pop	r9
 24a:	8f 90       	pop	r8
 24c:	7f 90       	pop	r7
 24e:	6f 90       	pop	r6
 250:	08 95       	ret

Disassembly of section .text._ZN6LSM3037headingEv:

00000000 <_ZN6LSM3037headingEv>:
{
	return io_timeout;
}

void LSM303::init(byte device, byte sa0_a)
{  
   0:	cf 92       	push	r12
   2:	df 92       	push	r13
   4:	ef 92       	push	r14
	_device = device;
   6:	ff 92       	push	r15
	switch (_device)
   8:	0f 93       	push	r16
   a:	1f 93       	push	r17
   c:	df 93       	push	r29
   e:	cf 93       	push	r28
  10:	cd b7       	in	r28, 0x3d	; 61
	{
	case LSM303DLH_DEVICE:
	case LSM303DLM_DEVICE:
		if (sa0_a == LSM303_SA0_A_LOW)
  12:	de b7       	in	r29, 0x3e	; 62
  14:	2c 97       	sbiw	r28, 0x0c	; 12
			acc_address = ACC_ADDRESS_SA0_A_LOW;
		else if (sa0_a == LSM303_SA0_A_HIGH)
  16:	0f b6       	in	r0, 0x3f	; 63
  18:	f8 94       	cli
			acc_address = ACC_ADDRESS_SA0_A_HIGH;
		else
			acc_address = (detectSA0_A() == LSM303_SA0_A_HIGH) ? ACC_ADDRESS_SA0_A_HIGH : ACC_ADDRESS_SA0_A_LOW;
  1a:	de bf       	out	0x3e, r29	; 62
  1c:	0f be       	out	0x3f, r0	; 63
  1e:	cd bf       	out	0x3d, r28	; 61
  20:	20 e0       	ldi	r18, 0x00	; 0
  22:	30 e0       	ldi	r19, 0x00	; 0
  24:	a9 01       	movw	r20, r18
		break;

	case LSM303DLHC_DEVICE:
		acc_address = ACC_ADDRESS_SA0_A_HIGH;
  26:	29 83       	std	Y+1, r18	; 0x01
  28:	3a 83       	std	Y+2, r19	; 0x02
		break;
  2a:	4b 83       	std	Y+3, r20	; 0x03

	default:
		// try to auto-detect device
		if (detectSA0_A() == LSM303_SA0_A_HIGH)
  2c:	5c 83       	std	Y+4, r21	; 0x04
  2e:	0f 2e       	mov	r0, r31
  30:	f0 e0       	ldi	r31, 0x00	; 0
  32:	ef 2e       	mov	r14, r31
		{
			// if device responds on 0011001b (SA0_A is high), assume DLHC
			acc_address = ACC_ADDRESS_SA0_A_HIGH;
  34:	f0 e0       	ldi	r31, 0x00	; 0
  36:	ff 2e       	mov	r15, r31
			_device = LSM303DLHC_DEVICE;
  38:	f0 e8       	ldi	r31, 0x80	; 128
  3a:	0f 2f       	mov	r16, r31
  3c:	ff eb       	ldi	r31, 0xBF	; 191
		}
		else
		{
			// otherwise, assume DLH or DLM (pulled low by default on Pololu boards); query magnetometer WHO_AM_I to differentiate these two
			acc_address = ACC_ADDRESS_SA0_A_LOW;
  3e:	1f 2f       	mov	r17, r31
  40:	f0 2d       	mov	r31, r0
			_device = (readMagReg(LSM303_WHO_AM_I_M) == 0x3C) ? LSM303DLM_DEVICE : LSM303DLH_DEVICE;
  42:	ed 82       	std	Y+5, r14	; 0x05
  44:	fe 82       	std	Y+6, r15	; 0x06
  46:	0f 83       	std	Y+7, r16	; 0x07
  48:	18 87       	std	Y+8, r17	; 0x08
  4a:	29 87       	std	Y+9, r18	; 0x09
  4c:	3a 87       	std	Y+10, r19	; 0x0a
  4e:	4b 87       	std	Y+11, r20	; 0x0b
  50:	5c 87       	std	Y+12, r21	; 0x0c
  52:	cc 24       	eor	r12, r12
  54:	da 80       	ldd	r13, Y+2	; 0x02
		}
		break;
	}
}
  56:	eb 80       	ldd	r14, Y+3	; 0x03
  58:	fc 80       	ldd	r15, Y+4	; 0x04
  5a:	00 e0       	ldi	r16, 0x00	; 0
  5c:	1e 81       	ldd	r17, Y+6	; 0x06
  5e:	2f 81       	ldd	r18, Y+7	; 0x07
  60:	38 85       	ldd	r19, Y+8	; 0x08
  62:	40 e0       	ldi	r20, 0x00	; 0
  64:	5a 85       	ldd	r21, Y+10	; 0x0a
  66:	6b 85       	ldd	r22, Y+11	; 0x0b
  68:	7c 85       	ldd	r23, Y+12	; 0x0c
  6a:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM3037headingEv>
  6e:	2c 96       	adiw	r28, 0x0c	; 12
  70:	0f b6       	in	r0, 0x3f	; 63
  72:	f8 94       	cli
  74:	de bf       	out	0x3e, r29	; 62
  76:	0f be       	out	0x3f, r0	; 63
  78:	cd bf       	out	0x3d, r28	; 61
  7a:	cf 91       	pop	r28
  7c:	df 91       	pop	r29
  7e:	1f 91       	pop	r17
  80:	0f 91       	pop	r16
  82:	ff 90       	pop	r15
  84:	ef 90       	pop	r14
  86:	df 90       	pop	r13
  88:	cf 90       	pop	r12
  8a:	08 95       	ret

Disassembly of section .text._ZN6LSM30311detectSA0_AEv:

00000000 <_ZN6LSM30311detectSA0_AEv>:
{
	return io_timeout;
}

void LSM303::init(byte device, byte sa0_a)
{  
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	ec 01       	movw	r28, r24
	_device = device;
   6:	80 e0       	ldi	r24, 0x00	; 0
	switch (_device)
   8:	90 e0       	ldi	r25, 0x00	; 0
   a:	68 e1       	ldi	r22, 0x18	; 24
   c:	70 e0       	ldi	r23, 0x00	; 0
   e:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM30311detectSA0_AEv>
	{
	case LSM303DLH_DEVICE:
	case LSM303DLM_DEVICE:
		if (sa0_a == LSM303_SA0_A_LOW)
  12:	80 e0       	ldi	r24, 0x00	; 0
  14:	90 e0       	ldi	r25, 0x00	; 0
			acc_address = ACC_ADDRESS_SA0_A_LOW;
		else if (sa0_a == LSM303_SA0_A_HIGH)
  16:	60 e2       	ldi	r22, 0x20	; 32
  18:	70 e0       	ldi	r23, 0x00	; 0
			acc_address = ACC_ADDRESS_SA0_A_HIGH;
		else
			acc_address = (detectSA0_A() == LSM303_SA0_A_HIGH) ? ACC_ADDRESS_SA0_A_HIGH : ACC_ADDRESS_SA0_A_LOW;
  1a:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM30311detectSA0_AEv>
  1e:	80 e0       	ldi	r24, 0x00	; 0
  20:	90 e0       	ldi	r25, 0x00	; 0
  22:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM30311detectSA0_AEv>
		break;

	case LSM303DLHC_DEVICE:
		acc_address = ACC_ADDRESS_SA0_A_HIGH;
  26:	88 ab       	std	Y+48, r24	; 0x30
  28:	80 e0       	ldi	r24, 0x00	; 0
		break;
  2a:	90 e0       	ldi	r25, 0x00	; 0

	default:
		// try to auto-detect device
		if (detectSA0_A() == LSM303_SA0_A_HIGH)
  2c:	68 e1       	ldi	r22, 0x18	; 24
  2e:	70 e0       	ldi	r23, 0x00	; 0
  30:	41 e0       	ldi	r20, 0x01	; 1
  32:	50 e0       	ldi	r21, 0x00	; 0
		{
			// if device responds on 0011001b (SA0_A is high), assume DLHC
			acc_address = ACC_ADDRESS_SA0_A_HIGH;
  34:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM30311detectSA0_AEv>
			_device = LSM303DLHC_DEVICE;
  38:	80 e0       	ldi	r24, 0x00	; 0
  3a:	90 e0       	ldi	r25, 0x00	; 0
  3c:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM30311detectSA0_AEv>
		}
		else
		{
			// otherwise, assume DLH or DLM (pulled low by default on Pololu boards); query magnetometer WHO_AM_I to differentiate these two
			acc_address = ACC_ADDRESS_SA0_A_LOW;
  40:	00 97       	sbiw	r24, 0x00	; 0
			_device = (readMagReg(LSM303_WHO_AM_I_M) == 0x3C) ? LSM303DLM_DEVICE : LSM303DLH_DEVICE;
  42:	01 f0       	breq	.+0      	; 0x44 <_ZN6LSM30311detectSA0_AEv+0x44>
  44:	80 e0       	ldi	r24, 0x00	; 0
  46:	90 e0       	ldi	r25, 0x00	; 0
  48:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM30311detectSA0_AEv>
  4c:	80 e0       	ldi	r24, 0x00	; 0
  4e:	00 c0       	rjmp	.+0      	; 0x50 <_ZN6LSM30311detectSA0_AEv+0x50>
  50:	81 e0       	ldi	r24, 0x01	; 1
  52:	df 91       	pop	r29
  54:	cf 91       	pop	r28
		}
		break;
	}
}
  56:	08 95       	ret

Disassembly of section .text._ZN6LSM3034initEhh:

00000000 <_ZN6LSM3034initEhh>:
{
	return io_timeout;
}

void LSM303::init(byte device, byte sa0_a)
{  
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	ec 01       	movw	r28, r24
	_device = device;
   6:	69 ab       	std	Y+49, r22	; 0x31
	switch (_device)
   8:	62 30       	cpi	r22, 0x02	; 2
   a:	00 f0       	brcs	.+0      	; 0xc <_ZN6LSM3034initEhh+0xc>
   c:	62 30       	cpi	r22, 0x02	; 2
   e:	01 f4       	brne	.+0      	; 0x10 <_ZN6LSM3034initEhh+0x10>
  10:	00 c0       	rjmp	.+0      	; 0x12 <_ZN6LSM3034initEhh+0x12>
	{
	case LSM303DLH_DEVICE:
	case LSM303DLM_DEVICE:
		if (sa0_a == LSM303_SA0_A_LOW)
  12:	44 23       	and	r20, r20
  14:	01 f0       	breq	.+0      	; 0x16 <_ZN6LSM3034initEhh+0x16>
			acc_address = ACC_ADDRESS_SA0_A_LOW;
		else if (sa0_a == LSM303_SA0_A_HIGH)
  16:	41 30       	cpi	r20, 0x01	; 1
  18:	01 f0       	breq	.+0      	; 0x1a <_ZN6LSM3034initEhh+0x1a>
			acc_address = ACC_ADDRESS_SA0_A_HIGH;
		else
			acc_address = (detectSA0_A() == LSM303_SA0_A_HIGH) ? ACC_ADDRESS_SA0_A_HIGH : ACC_ADDRESS_SA0_A_LOW;
  1a:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM3034initEhh>
  1e:	81 30       	cpi	r24, 0x01	; 1
  20:	01 f0       	breq	.+0      	; 0x22 <_ZN6LSM3034initEhh+0x22>
  22:	88 e1       	ldi	r24, 0x18	; 24
  24:	00 c0       	rjmp	.+0      	; 0x26 <_ZN6LSM3034initEhh+0x26>
		break;

	case LSM303DLHC_DEVICE:
		acc_address = ACC_ADDRESS_SA0_A_HIGH;
  26:	89 e1       	ldi	r24, 0x19	; 25
  28:	8a ab       	std	Y+50, r24	; 0x32
		break;
  2a:	00 c0       	rjmp	.+0      	; 0x2c <_ZN6LSM3034initEhh+0x2c>

	default:
		// try to auto-detect device
		if (detectSA0_A() == LSM303_SA0_A_HIGH)
  2c:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM3034initEhh>
  30:	81 30       	cpi	r24, 0x01	; 1
  32:	01 f4       	brne	.+0      	; 0x34 <_ZN6LSM3034initEhh+0x34>
		{
			// if device responds on 0011001b (SA0_A is high), assume DLHC
			acc_address = ACC_ADDRESS_SA0_A_HIGH;
  34:	89 e1       	ldi	r24, 0x19	; 25
  36:	8a ab       	std	Y+50, r24	; 0x32
			_device = LSM303DLHC_DEVICE;
  38:	82 e0       	ldi	r24, 0x02	; 2
  3a:	89 ab       	std	Y+49, r24	; 0x31
  3c:	00 c0       	rjmp	.+0      	; 0x3e <_ZN6LSM3034initEhh+0x3e>
		}
		else
		{
			// otherwise, assume DLH or DLM (pulled low by default on Pololu boards); query magnetometer WHO_AM_I to differentiate these two
			acc_address = ACC_ADDRESS_SA0_A_LOW;
  3e:	88 e1       	ldi	r24, 0x18	; 24
  40:	8a ab       	std	Y+50, r24	; 0x32
			_device = (readMagReg(LSM303_WHO_AM_I_M) == 0x3C) ? LSM303DLM_DEVICE : LSM303DLH_DEVICE;
  42:	ce 01       	movw	r24, r28
  44:	6f e0       	ldi	r22, 0x0F	; 15
  46:	70 e0       	ldi	r23, 0x00	; 0
  48:	0e 94 00 00 	call	0	; 0x0 <_ZN6LSM3034initEhh>
  4c:	91 e0       	ldi	r25, 0x01	; 1
  4e:	8c 33       	cpi	r24, 0x3C	; 60
  50:	01 f0       	breq	.+0      	; 0x52 <_ZN6LSM3034initEhh+0x52>
  52:	90 e0       	ldi	r25, 0x00	; 0
  54:	99 ab       	std	Y+49, r25	; 0x31
		}
		break;
	}
}
  56:	df 91       	pop	r29
  58:	cf 91       	pop	r28
  5a:	08 95       	ret
